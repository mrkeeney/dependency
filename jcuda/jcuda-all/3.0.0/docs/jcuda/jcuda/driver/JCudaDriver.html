<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_04) on Thu Mar 25 20:46:30 CET 2010 -->
<TITLE>
JCudaDriver (JCuda API Documentation)
</TITLE>

<META NAME="date" CONTENT="2010-03-25">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JCudaDriver (JCuda API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCudaDriver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/driver/JCudaDriver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCudaDriver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jcuda.driver</FONT>
<BR>
Class JCudaDriver</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>jcuda.driver.JCudaDriver</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>JCudaDriver</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Java bindings for the NVidia CUDA driver API.<br />
 <br />
 Most comments are taken from the CUDA reference manual
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_DEVICEMAP">CU_MEMHOSTALLOC_DEVICEMAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is mapped into CUDA address space and
 JCudaDriver#cuMemHostGetDevicePointer may be called on the host pointer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_PORTABLE">CU_MEMHOSTALLOC_PORTABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is portable between CUDA contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_MEMHOSTALLOC_WRITECOMBINED">CU_MEMHOSTALLOC_WRITECOMBINED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, host memory is allocated as write-combined - fast to write,
 faster to DMA, slow to read except via SSE4 streaming load instruction
 (MOVNTDQA).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_PARAM_TR_DEFAULT">CU_PARAM_TR_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For texture references loaded into the module, use default 
 texunit from texture reference</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSA_OVERRIDE_FORMAT">CU_TRSA_OVERRIDE_FORMAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override the texref format with a format inferred from the array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSF_NORMALIZED_COORDINATES">CU_TRSF_NORMALIZED_COORDINATES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use normalized texture coordinates in the range [0,1) instead of [0,dim)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CU_TRSF_READ_AS_INTEGER">CU_TRSF_READ_AS_INTEGER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the texture as integers rather than promoting the values
 to floats in the range [0,1]</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_ARRAY3D_2DARRAY">CUDA_ARRAY3D_2DARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, the CUDA array contains an array of 2D slices
 and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies
 the number of slices, not the depth of a 3D array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#CUDA_VERSION">CUDA_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#align(int, int)">align</A></B>(int&nbsp;value,
      int&nbsp;alignment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the given (address) value, adjusted to have
 the given alignment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)">cuArray3DCreate</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pAllocateArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)">cuArray3DGetDescriptor</A></B>(<A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                       <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a 3D CUDA array descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)">cuArrayCreate</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
              <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pAllocateArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a 1D or 2D CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)">cuArrayDestroy</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a CUDA array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)">cuArrayGetDescriptor</A></B>(<A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                     <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a 1D or 2D CUDA array descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)">cuCtxAttach</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
            int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment context usage-count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)">cuCtxCreate</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
            int&nbsp;flags,
            <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a CUDA context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)">cuCtxDestroy</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy the current context context or a floating CuDA context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)">cuCtxDetach</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement a context’s usage-count.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)">cuCtxGetDevice</A></B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return device-ID for current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)">cuCtxPopCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pops the current CUDA context from the current CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)">cuCtxPushCurrent</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach floating context to CPU thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()">cuCtxSynchronize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block for a context’s tasks to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)">cuDeviceComputeCapability</A></B>(int[]&nbsp;major,
                          int[]&nbsp;minor,
                          <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the compute capability of the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)">cuDeviceGet</A></B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device,
            int&nbsp;ordinal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a device-handle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)">cuDeviceGetAttribute</A></B>(int[]&nbsp;pi,
                     int&nbsp;attrib,
                     <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])">cuDeviceGetCount</A></B>(int[]&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of compute-capable devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)">cuDeviceGetName</A></B>(byte[]&nbsp;name,
                int&nbsp;len,
                <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an identifier string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)">cuDeviceGetProperties</A></B>(<A HREF="../../jcuda/driver/CUdevprop.html" title="class in jcuda.driver">CUdevprop</A>&nbsp;prop,
                      <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get device properties.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)">cuDeviceTotalMem</A></B>(int[]&nbsp;bytes,
                 <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total amount of memory on the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuDriverGetVersion(int[])">cuDriverGetVersion</A></B>(int[]&nbsp;driverVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in driverVersion the version number of the installed CUDA driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)">cuEventCreate</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
              int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)">cuEventDestroy</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)">cuEventElapsedTime</A></B>(float[]&nbsp;pMilliseconds,
                   <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hStart,
                   <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEnd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the elapsed time between two events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)">cuEventQuery</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries an event’s status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)">cuEventRecord</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
              <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Records an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)">cuEventSynchronize</A></B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for an event to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)">cuFuncGetAttribute</A></B>(int[]&nbsp;pi,
                   int&nbsp;attrib,
                   <A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in pi the integer value of the attribute attrib on the kernel given by func.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)">cuFuncSetBlockShape</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the block-dimensions for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)">cuFuncSetCacheConfig</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                     int&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the preferred cache configuration for the device function hfunc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)">cuFuncSetSharedSize</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    int&nbsp;bytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the shared-memory size for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)">cuGLCtxCreate</A></B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pCtx,
              int&nbsp;Flags,
              <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a CUDA context for interoperability with OpenGL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()">cuGLInit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)">cuGLMapBufferObject</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                    int[]&nbsp;size,
                    int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)">cuGLMapBufferObjectAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                         int[]&nbsp;size,
                         int&nbsp;buffer,
                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)">cuGLRegisterBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)">cuGLSetBufferObjectMapFlags</A></B>(int&nbsp;buffer,
                            int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)">cuGLUnmapBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)">cuGLUnmapBufferObjectAsync</A></B>(int&nbsp;buffer,
                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)">cuGLUnregisterBufferObject</A></B>(int&nbsp;bufferobj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)">cuGraphicsGLRegisterBuffer</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                           int&nbsp;buffer,
                           int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers the buffer object specified by buffer for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)">cuGraphicsGLRegisterImage</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                          int&nbsp;image,
                          int&nbsp;target,
                          int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers the texture or renderbuffer object specified by image for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)">cuGraphicsMapResources</A></B>(int&nbsp;count,
                       <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                       <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps the count graphics resources in resources for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)">cuGraphicsResourceGetMappedPointer</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pDevPtr,
                                   int[]&nbsp;pSize,
                                   <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *pDevPtr a pointer through which the mapped graphics resource resource 
 may be accessed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)">cuGraphicsResourceSetMapFlags</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set flags for mapping the graphics resource resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)">cuGraphicsSubResourceGetMappedArray</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pArray,
                                    <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                    int&nbsp;arrayIndex,
                                    int&nbsp;mipLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *pArray an array through which the subresource of the mapped 
 graphics resource resource which corresponds to array index arrayIndex 
 and mipmap level mipLevel may be accessed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)">cuGraphicsUnmapResources</A></B>(int&nbsp;count,
                         <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps the count graphics resources in resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)">cuGraphicsUnregisterResource</A></B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters the graphics resource resource so it is not accessible by CUDA unless registered again.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuInit(int)">cuInit</A></B>(int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialize the CUDA driver API.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)">cuLaunch</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)">cuLaunchGrid</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
             int&nbsp;grid_width,
             int&nbsp;grid_height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a CUDA function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)">cuLaunchGridAsync</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                  int&nbsp;grid_width,
                  int&nbsp;grid_height,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)">cuMemAlloc</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
           int&nbsp;bytesize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)">cuMemAllocHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
               int&nbsp;bytesize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates page-locked host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)">cuMemAllocPitch</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                int[]&nbsp;pPitch,
                int&nbsp;WidthInBytes,
                int&nbsp;Height,
                int&nbsp;ElementSizeBytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)">cuMemcpy2D</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 2D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)">cuMemcpy2DAsync</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy,
                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)">cuMemcpy2DUnaligned</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)">cuMemcpy3D</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory for 3D arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)">cuMemcpy3DAsync</A></B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy,
                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)">cuMemcpyAtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             int&nbsp;dstIndex,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
             int&nbsp;srcIndex,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)">cuMemcpyAtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hSrc,
             int&nbsp;SrcIndex,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)">cuMemcpyAtoH</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
             <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
             int&nbsp;srcIndex,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Array to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)">cuMemcpyAtoHAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                  <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                  int&nbsp;srcIndex,
                  int&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)">cuMemcpyDtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             int&nbsp;dstIndex,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)">cuMemcpyDtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)">cuMemcpyDtoDAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                  int&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)">cuMemcpyDtoH</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
             <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Device to Host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)">cuMemcpyDtoHAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                  <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                  int&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)">cuMemcpyHtoA</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
             int&nbsp;dstIndex,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory from Host to Array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)">cuMemcpyHtoAAsync</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                  int&nbsp;dstIndex,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                  int&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)">cuMemcpyHtoD</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
             int&nbsp;ByteCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy memory from Host to Device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)">cuMemcpyHtoDAsync</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                  int&nbsp;ByteCount,
                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)">cuMemFree</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)">cuMemFreeHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees page-locked host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)">cuMemGetAddressRange</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pbase,
                     int[]&nbsp;psize,
                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get information on memory allocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])">cuMemGetInfo</A></B>(int[]&nbsp;free,
             int[]&nbsp;total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets free and total memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)">cuMemHostAlloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
               long&nbsp;bytes,
               int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates bytes bytes of host memory that is page-locked and accessible to the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)">cuMemHostGetDevicePointer</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ret,
                          <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                          int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back the device pointer ret corresponding to the mapped, pinned host buffer p allocated by cuMemHostAlloc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetFlags(int[], jcuda.Pointer)">cuMemHostGetFlags</A></B>(int[]&nbsp;pFlags,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back the flags pFlags that were specified when allocating 
 the pinned host buffer p allocated by cuMemHostAlloc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)">cuMemsetD16</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
            short&nbsp;us,
            int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)">cuMemsetD2D16</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
              int&nbsp;dstPitch,
              short&nbsp;us,
              int&nbsp;Width,
              int&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)">cuMemsetD2D32</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
              int&nbsp;dstPitch,
              int&nbsp;ui,
              int&nbsp;Width,
              int&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)">cuMemsetD2D8</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
             int&nbsp;dstPitch,
             char&nbsp;uc,
             int&nbsp;Width,
             int&nbsp;Height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)">cuMemsetD32</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
            int&nbsp;ui,
            int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)">cuMemsetD8</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
           char&nbsp;uc,
           int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes device memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)">cuModuleGetFunction</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                    java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a function handle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)">cuModuleGetGlobal</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                  int[]&nbsp;bytes,
                  <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                  java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a global pointer from a module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)">cuModuleGetTexRef</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef,
                  <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                  java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a handle to a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)">cuModuleLoad</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
             java.lang.String&nbsp;fname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loads a compute module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])">cuModuleLoadData</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                 byte[]&nbsp;image)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loads a module’s data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)">cuModuleLoadDataEx</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;phMod,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                   int&nbsp;numOptions,
                   int[]&nbsp;options,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;optionValues)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Takes a pointer p and loads the corresponding module phMod into the current context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])">cuModuleLoadFatBinary</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                      byte[]&nbsp;fatCubin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loads a fat-binary object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)">cuModuleUnload</A></B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unloads a module.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)">cuParamSetf</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            float&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a floating-point parameter to the function’s argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)">cuParamSeti</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an integer parameter to the function’s argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)">cuParamSetSize</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
               int&nbsp;numbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameter-size for the function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)">cuParamSetTexRef</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                 int&nbsp;texunit,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a texture-reference to the function’s argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)">cuParamSetv</A></B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
            int&nbsp;offset,
            <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
            int&nbsp;numbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds arbitrary data to the function’s argument list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)">cuStreamCreate</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;phStream,
               int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)">cuStreamDestroy</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)">cuStreamQuery</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine status of a compute stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)">cuStreamSynchronize</A></B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block until a stream’s tasks are completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)">cuTexRefCreate</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)">cuTexRefDestroy</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)">cuTexRefGetAddress</A></B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the address associated with a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)">cuTexRefGetAddressMode</A></B>(int[]&nbsp;pam,
                       <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                       int&nbsp;dim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the addressing mode used by a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)">cuTexRefGetArray</A></B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array bound to a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)">cuTexRefGetFilterMode</A></B>(int[]&nbsp;pfm,
                      <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the filter-mode used by a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)">cuTexRefGetFlags</A></B>(int[]&nbsp;pFlags,
                 <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the flags used by a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)">cuTexRefGetFormat</A></B>(int[]&nbsp;pFormat,
                  int[]&nbsp;pNumChannels,
                  <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the format used by a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)">cuTexRefSetAddress</A></B>(int[]&nbsp;ByteOffset,
                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                   <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                   int&nbsp;bytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds an address as a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, int)">cuTexRefSetAddress2D</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                     <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;desc,
                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                     int&nbsp;PitchInBytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds a linear address range to the texture reference hTexRef.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)">cuTexRefSetAddressMode</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                       int&nbsp;dim,
                       int&nbsp;am)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the addressing mode for a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)">cuTexRefSetArray</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                 <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                 int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds an array to a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)">cuTexRefSetFilterMode</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                      int&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mode for a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)">cuTexRefSetFlags</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                 int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets flags for a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)">cuTexRefSetFormat</A></B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                  int&nbsp;fmt,
                  int&nbsp;NumPackedComponents)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the format for a texture-reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#setExceptionsEnabled(boolean)">setExceptionsEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables exceptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/driver/JCudaDriver.html#setLogLevel(jcuda.LogLevel)">setLogLevel</A></B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified log level for the JCuda driver library.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CUDA_VERSION"><!-- --></A><H3>
CUDA_VERSION</H3>
<PRE>
public static final int <B>CUDA_VERSION</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_VERSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_PORTABLE"><!-- --></A><H3>
CU_MEMHOSTALLOC_PORTABLE</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_PORTABLE</B></PRE>
<DL>
<DD>If set, host memory is portable between CUDA contexts.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_PORTABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_DEVICEMAP"><!-- --></A><H3>
CU_MEMHOSTALLOC_DEVICEMAP</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_DEVICEMAP</B></PRE>
<DL>
<DD>If set, host memory is mapped into CUDA address space and
 JCudaDriver#cuMemHostGetDevicePointer may be called on the host pointer.
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_DEVICEMAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_MEMHOSTALLOC_WRITECOMBINED"><!-- --></A><H3>
CU_MEMHOSTALLOC_WRITECOMBINED</H3>
<PRE>
public static final int <B>CU_MEMHOSTALLOC_WRITECOMBINED</B></PRE>
<DL>
<DD>If set, host memory is allocated as write-combined - fast to write,
 faster to DMA, slow to read except via SSE4 streaming load instruction
 (MOVNTDQA).
 Flag for <A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_MEMHOSTALLOC_WRITECOMBINED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CUDA_ARRAY3D_2DARRAY"><!-- --></A><H3>
CUDA_ARRAY3D_2DARRAY</H3>
<PRE>
public static final int <B>CUDA_ARRAY3D_2DARRAY</B></PRE>
<DL>
<DD>If set, the CUDA array contains an array of 2D slices
 and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies
 the number of slices, not the depth of a 3D array.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CUDA_ARRAY3D_2DARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_PARAM_TR_DEFAULT"><!-- --></A><H3>
CU_PARAM_TR_DEFAULT</H3>
<PRE>
public static final int <B>CU_PARAM_TR_DEFAULT</B></PRE>
<DL>
<DD>For texture references loaded into the module, use default 
 texunit from texture reference
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_PARAM_TR_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSA_OVERRIDE_FORMAT"><!-- --></A><H3>
CU_TRSA_OVERRIDE_FORMAT</H3>
<PRE>
public static final int <B>CU_TRSA_OVERRIDE_FORMAT</B></PRE>
<DL>
<DD>Override the texref format with a format inferred from the array
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSA_OVERRIDE_FORMAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSF_READ_AS_INTEGER"><!-- --></A><H3>
CU_TRSF_READ_AS_INTEGER</H3>
<PRE>
public static final int <B>CU_TRSF_READ_AS_INTEGER</B></PRE>
<DL>
<DD>Read the texture as integers rather than promoting the values
 to floats in the range [0,1]
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSF_READ_AS_INTEGER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CU_TRSF_NORMALIZED_COORDINATES"><!-- --></A><H3>
CU_TRSF_NORMALIZED_COORDINATES</H3>
<PRE>
public static final int <B>CU_TRSF_NORMALIZED_COORDINATES</B></PRE>
<DL>
<DD>Use normalized texture coordinates in the range [0,1) instead of [0,dim)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.driver.JCudaDriver.CU_TRSF_NORMALIZED_COORDINATES">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setLogLevel(jcuda.LogLevel)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public static void <B>setLogLevel</B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</PRE>
<DL>
<DD>Set the specified log level for the JCuda driver library.<br />
 <br />
 Currently supported log levels:
 <br />
 LOG_QUIET: Never print anything <br />
 LOG_ERROR: Print error messages <br />
 LOG_TRACE: Print a trace of all native function calls <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The log level to use.</DL>
</DD>
</DL>
<HR>

<A NAME="setExceptionsEnabled(boolean)"><!-- --></A><H3>
setExceptionsEnabled</H3>
<PRE>
public static void <B>setExceptionsEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enables or disables exceptions. By default, the methods of this class
 only return the CUresult error code from the underlying CUDA function.
 If exceptions are enabled, a CudaException with a detailed error 
 message will be thrown if a method is about to return a result code 
 that is not CUresult.CUDA_SUCCESS
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - Whether exceptions are enabled</DL>
</DD>
</DL>
<HR>

<A NAME="align(int, int)"><!-- --></A><H3>
align</H3>
<PRE>
public static int <B>align</B>(int&nbsp;value,
                        int&nbsp;alignment)</PRE>
<DL>
<DD>Returns the given (address) value, adjusted to have
 the given alignment. This function may be used to 
 align the parameters for a kernel call according 
 to their alignment requirements.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - The address value<DD><CODE>alignment</CODE> - The desired alignment
<DT><B>Returns:</B><DD>The aligned address value</DL>
</DD>
</DL>
<HR>

<A NAME="cuInit(int)"><!-- --></A><H3>
cuInit</H3>
<PRE>
public static int <B>cuInit</B>(int&nbsp;Flags)</PRE>
<DL>
<DD>Initialize the CUDA driver API.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuInit( unsigned int Flags );
 <br />
 <br />
 DESCRIPTION<br />
 Initializes the driver API and must be called before any other function from the driver API. Currently, the
 Flags parameters must be 0. If cuInit() has not been called, any function from the driver API will return
 CUDA_ERROR_NOT_INITIALIZED.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NO_DEVICE,</DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGet(jcuda.driver.CUdevice, int)"><!-- --></A><H3>
cuDeviceGet</H3>
<PRE>
public static int <B>cuDeviceGet</B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device,
                              int&nbsp;ordinal)</PRE>
<DL>
<DD>Returns a device-handle.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceGet(CUdevice* dev, int ordinal);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *dev a device handle given an ordinal in the range [0, cuDeviceGetCount()-1].
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetCount(int[])"><!-- --></A><H3>
cuDeviceGetCount</H3>
<PRE>
public static int <B>cuDeviceGetCount</B>(int[]&nbsp;count)</PRE>
<DL>
<DD>Returns the number of compute-capable devices.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceGetCount(int* count);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *count the number of devices with compute capability greater or equal to 1.0 that are available
 for execution. If there is no such device, cuDeviceGetCount() returns 0.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetName</H3>
<PRE>
public static int <B>cuDeviceGetName</B>(byte[]&nbsp;name,
                                  int&nbsp;len,
                                  <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns an identifier string.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceGetName(char* name, int len, CUdevice dev);
 <br />
 <br />
 DESCRIPTION<br />
 Returns an ASCII string identifying the device dev in the NULL-terminated string pointed to by name.
 len specifies the maximum length of the string that may be returned.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceComputeCapability</H3>
<PRE>
public static int <B>cuDeviceComputeCapability</B>(int[]&nbsp;major,
                                            int[]&nbsp;minor,
                                            <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns the compute capability of the device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceComputeCapability(int* major, int* minor, CUdevice dev);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *major and *minor the major and minor revision numbers that define the compute capability
 of device dev.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceTotalMem</H3>
<PRE>
public static int <B>cuDeviceTotalMem</B>(int[]&nbsp;bytes,
                                   <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns the total amount of memory on the device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceTotalMem( unsigned int* bytes, CUdevice dev );
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *bytes the total amount of memory available on the device dev in bytes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetProperties</H3>
<PRE>
public static int <B>cuDeviceGetProperties</B>(<A HREF="../../jcuda/driver/CUdevprop.html" title="class in jcuda.driver">CUdevprop</A>&nbsp;prop,
                                        <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Get device properties.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceGetProperties(CUdevprop* prop, CUdevice dev);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *prop the properties of device dev. The CUdevprop structure is defined as:
 <pre>
 typedef struct CUdevprop_st {
     int maxThreadsPerBlock;
     int maxThreadsDim[3];
     int maxGridSize[3];
     int sharedMemPerBlock;
     int totalConstantMemory;
     int SIMDWidth;
     int memPitch;
     int regsPerBlock;
     int clockRate;
     int textureAlign
 } CUdevprop;
 </pre>
 where:
 - maxThreadsPerBlock is the maximum number of threads per block;
 - maxThreadsDim[3] is the maximum sizes of each dimension of a block;
 - maxGridSize[3] is the maximum sizes of each dimension of a grid;
 - sharedMemPerBlock is the total amount of shared memory available per block in bytes;
 - totalConstantMemory is the total amount of constant memory available on the device in bytes;
 - SIMDWidth is the warp size;
 - memPitch is the maximum pitch allowed by the memory copy functions that involve memory regions
 allocated through cuMemAllocPitch();
 - regsPerBlock is the total number of registers available per block;
 - clockRate is the clock frequency in kilohertz;
 - textureAlign is the alignment requirement; texture base addresses that are aligned to textureAlign
 bytes do not need an offset applied to texture fetches.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDeviceGetAttribute(int[], int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuDeviceGetAttribute</H3>
<PRE>
public static int <B>cuDeviceGetAttribute</B>(int[]&nbsp;pi,
                                       int&nbsp;attrib,
                                       <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Returns information about the device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuDeviceGetAttribute(int* value, CUdevice_attribute attrib, CUdevice dev);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *value the integer value of the attribute attrib on device dev. The supported attributes are:
 - CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: maximum number of threads
 per block;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: maximum x-dimension of a block;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: maximum y-dimension of a block;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: maximum z-dimension of a block;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: maximum x-dimension of a grid;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: maximum y-dimension of a grid;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: maximum z-dimension of a grid;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: maximum amount
 of shared memory available to a thread block in bytes; this amount is shared by all thread blocks si-
 multaneously resident on a multiprocessor;<br />
 - CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: total amount of constant
 memory available on the device in bytes;<br />
 - CU_DEVICE_ATTRIBUTE_WARP_SIZE: warp size in threads;<br />
 - CU_DEVICE_ATTRIBUTE_MAX_PITCH: maximum pitch in bytes allowed by the memory
 copy functions that involve memory regions allocated through cuMemAllocPitch();<br />
 - CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: maximum number of
 32-bit registers available to a thread block; this number is shared by all thread blocks simultaneously
 resident on a multiprocessor;<br />
 - CU_DEVICE_ATTRIBUTE_CLOCK_RATE: clock frequency in kilohertz;<br />
 - CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: alignment requirement; texture
 base addresses aligned to textureAlign bytes do not need an offset applied to texture fetches;<br />
 - CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: 1 if the device can concurrently copy mem-
 ory between host and device while executing a kernel, or 0 if not;<br />
 - CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: number of multiprocessors
 on the device.<br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_DEVICE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)"><CODE>cuDeviceComputeCapability(int[], int[], jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetCount(int[])"><CODE>cuDeviceGetCount(int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)"><CODE>cuDeviceGetName(byte[], int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGet(jcuda.driver.CUdevice, int)"><CODE>cuDeviceGet(jcuda.driver.CUdevice, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)"><CODE>cuDeviceGetProperties(jcuda.driver.CUdevprop, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuDeviceTotalMem(int[], jcuda.driver.CUdevice)"><CODE>cuDeviceTotalMem(int[], jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuDriverGetVersion(int[])"><!-- --></A><H3>
cuDriverGetVersion</H3>
<PRE>
public static int <B>cuDriverGetVersion</B>(int[]&nbsp;driverVersion)</PRE>
<DL>
<DD>Returns in driverVersion the version number of the installed CUDA driver. This function automatically returns
 CUDA_ERROR_INVALID_VALUE if the driverVersion argument is NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverVersion</CODE> - - Returns the CUDA driver version
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_VALUE</DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuCtxCreate</H3>
<PRE>
public static int <B>cuCtxCreate</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
                              int&nbsp;flags,
                              <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;dev)</PRE>
<DL>
<DD>Create a CUDA context.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxCreate(CUcontext* pCtx, unsigned int Flags, CUdevice dev);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a new CUDA context and associates it with the calling thread. The Flags parameter is described
 below. The context is created with a usage count of 1 and the caller of cuCtxCreate() must call cuCtxDe-
 stroy() or cuCtxDetach() when done using the context. If a context is already current to the thread, it is
 supplanted by the newly created context and may be restored by a subsequent call to cuCtxPopCurrent().
 The two LSBs of the Flags parameter can be used to control how the OS thread which owns the CUDA
 context at the time of an API call interacts with the OS scheduler when waiting for results from the GPU.
 <br />
 The two LSBs of the Flags parameter can be used to control how the OS thread, which owns the CUDA context at
 the time of an API call, interacts with the OS scheduler when waiting for results from the GPU.<br />
 - CU_CTX_SCHED_AUTO: The default value if the Flags parameter is zero, uses a heuristic based on the
 number of active CUDA contexts in the process C and the number of logical processors in the system P. If C &gt;
 P, then CUDA will yield to other OS threads when waiting for the GPU, otherwise CUDA will not yield while
 waiting for results and actively spin on the processor.<br />
 - CU_CTX_SCHED_SPIN: Instruct CUDA to actively spin when waiting for results from the GPU. This can decrease
 latency when waiting for the GPU, but may lower the performance of CPU threads if they are performing
 work in parallel with the CUDA thread.<br />
 - CU_CTX_SCHED_YIELD: Instruct CUDA to yield its thread when waiting for results from the GPU. This can
 increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work
 in parallel with the GPU.<br />
 - CU_CTX_BLOCKING_SYNC: Instruct CUDA to block the CPU thread on a synchronization primitive when
 waiting for the GPU to finish work.<br />
 - CU_CTX_MAP_HOST: Instruct CUDA to support mapped pinned allocations. This flag must be set in order
 to allocate pinned host memory that is accessible to the GPU.<br />
 <br />
 <b>Note to Linux users:</b><br />
 Context creation will fail with CUDA_ERROR_UNKNOWN if the compute mode of the device is 
 CU_COMPUTEMODE_PROHIBITED. Similarly, context creation will also fail with CUDA_ERROR_UNKNOWN if
 the compute mode for the device is set to CU_COMPUTEMODE_EXCLUSIVE and there is already an active context
 on the device. The function cuDeviceGetAttribute() can be used with CU_DEVICE_ATTRIBUTE_COMPUTE_MODE 
 to determine the compute mode of the device. The nvidia-smi tool can be used to set the compute mode for
 devices. Documentation for nvidia-smi can be obtained by passing a -h option to it.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, 
 CUDA_ERROR_INVALID_DEVICE, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxDestroy(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxDestroy</H3>
<PRE>
public static int <B>cuCtxDestroy</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Destroy the current context context or a floating CuDA context.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxDestroy(CUcontext ctx);
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the given CUDA context. If the context usage count is not equal to 1, or the context is current to
 any CPU thread other than the current one, this function fails. Floating contexts (detached from a CPU
 thread via cuCtxPopCurrent()) may be destroyed by this function.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxAttach(jcuda.driver.CUcontext, int)"><!-- --></A><H3>
cuCtxAttach</H3>
<PRE>
public static int <B>cuCtxAttach</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx,
                              int&nbsp;flags)</PRE>
<DL>
<DD>Increment context usage-count.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxAttach(CUcontext* pCtx, unsigned int Flags);
 <br />
 <br />
 DESCRIPTION<br />
 Increments the usage count of the context and passes back a context handle in *pCtx that must be passed to
 cuCtxDetach() when the application is done with the context. cuCtxAttach() fails if there is no context
 current to the thread.
 Currently, the Flags parameter must be 0.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxDetach(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxDetach</H3>
<PRE>
public static int <B>cuCtxDetach</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Decrement a context’s usage-count.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxDetach(CUcontext ctx);
 <br />
 <br />
 DESCRIPTION<br />
 Decrements the usage count of the context, and destroys the context if the usage count goes to 0. The context
 must be a handle that was passed back by cuCtxCreate() or cuCtxAttach(), and must be current to the
 calling thread.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxPushCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxPushCurrent</H3>
<PRE>
public static int <B>cuCtxPushCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;ctx)</PRE>
<DL>
<DD>Attach floating context to CPU thread.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxPushCurrent(CUcontext ctx);
 <br />
 <br />
 DESCRIPTION<br />
 Pushes the given context onto the CPU thread’s stack of current contexts. The specified context becomes
 the CPU thread’s current context, so all CUDA functions that operate on the current context are affected.
 The previous current context may be made current again by calling cuCtxDestroy() or cuCtxPopCur-
 rent().
 The context must be &quot;floating,&quot; i.e. not attached to any thread. Contexts are made to float by calling
 cuCtxPopCurrent().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPopCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPopCurrent(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxPopCurrent(jcuda.driver.CUcontext)"><!-- --></A><H3>
cuCtxPopCurrent</H3>
<PRE>
public static int <B>cuCtxPopCurrent</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pctx)</PRE>
<DL>
<DD>Pops the current CUDA context from the current CPU thread.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxPopCurrent(CUcontext *pctx);
 <br />
 <br />
 DESCRIPTION<br />
 Pops the current CUDA context from the CPU thread. The CUDA context must have a usage count
 of 1. CUDA contexts have a usage count of 1 upon creation; the usage count may be incremented with
 cuCtxAttach() and decremented with cuCtxDetach().
 If successful, cuCtxPopCurrent() passes back the context handle in *pctx. The context may then be
 made current to a different CPU thread by calling cuCtxPushCurrent().
 Floating contexts may be destroyed by calling cuCtxDestroy().
 If a context was current to the CPU thread before cuCtxCreate or cuCtxPushCurrent was called, this
 function makes that context current to the CPU thread again.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDestroy(jcuda.driver.CUcontext)"><CODE>cuCtxDestroy(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxPushCurrent(jcuda.driver.CUcontext)"><CODE>cuCtxPushCurrent(jcuda.driver.CUcontext)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxGetDevice(jcuda.driver.CUdevice)"><!-- --></A><H3>
cuCtxGetDevice</H3>
<PRE>
public static int <B>cuCtxGetDevice</B>(<A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</PRE>
<DL>
<DD>Return device-ID for current context.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxGetDevice(CUdevice* device);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *device the ordinal of the current context’s device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxSynchronize()"><CODE>cuCtxSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuCtxSynchronize()"><!-- --></A><H3>
cuCtxSynchronize</H3>
<PRE>
public static int <B>cuCtxSynchronize</B>()</PRE>
<DL>
<DD>Block for a context’s tasks to complete.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuCtxSynchronize(void);
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the device has completed all preceding requested tasks. cuCtxSynchronize() returns an error
 if one of the preceding tasks failed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxAttach(jcuda.driver.CUcontext, int)"><CODE>cuCtxAttach(jcuda.driver.CUcontext, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxDetach(jcuda.driver.CUcontext)"><CODE>cuCtxDetach(jcuda.driver.CUcontext)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxGetDevice(jcuda.driver.CUdevice)"><CODE>cuCtxGetDevice(jcuda.driver.CUdevice)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleLoad</H3>
<PRE>
public static int <B>cuModuleLoad</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                               java.lang.String&nbsp;fname)</PRE>
<DL>
<DD>Loads a compute module.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleLoad(CUmodule* mod, const char* filename);
 <br />
 <br />
 DESCRIPTION<br />
 Takes a file name filename and loads the corresponding module mod into the current context. The CUDA
 driver API does not attempt to lazily allocate the resources needed by a module; if the memory for functions
 and data (constant and global) needed by the module cannot be allocated, cuModuleLoad() fails. The file
 should be a cubin file as output by nvcc.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_FILE_NOT_FOUND,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><!-- --></A><H3>
cuModuleLoadData</H3>
<PRE>
public static int <B>cuModuleLoadData</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                                   byte[]&nbsp;image)</PRE>
<DL>
<DD>Loads a module’s data.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleLoadData(CUmodule* mod, const void* image);
 <br />
 <br />
 DESCRIPTION<br />
 Takes a pointer image and loads the corresponding module mod into the current context. The pointer may
 be obtained by mapping a cubin file, passing a cubin file as a text string, or incorporating a cubin object
 into the executable resources and using operation system calls such as Windowsâ?? FindResource() to
 obtain the pointer.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadDataEx(jcuda.driver.CUmodule, jcuda.Pointer, int, int[], jcuda.Pointer)"><!-- --></A><H3>
cuModuleLoadDataEx</H3>
<PRE>
public static int <B>cuModuleLoadDataEx</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;phMod,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                                     int&nbsp;numOptions,
                                     int[]&nbsp;options,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;optionValues)</PRE>
<DL>
<DD>Takes a pointer p and loads the corresponding module phMod into the current context. The pointer may be obtained
 by mapping a cubin or PTX file, passing a cubin or PTX file as a text string, or incorporating a cubin object into the
 executable resources and using operating system calls such as Windows FindResource() to obtain the pointer.
 Options are passed as an array via options and any corresponding parameters are passed in optionValues. The
 number of total options is supplied via numOptions. Any outputs will be returned via optionValues. Supported
 options are:<br />
 - CU_JIT_MAX_REGISTERS: input specifies the maximum number of registers per thread;<br />
 - CU_JIT_THREADS_PER_BLOCK: input specifies number of threads per block to target compilation for; output
 returns the number of threads the compiler actually targeted;<br />
 - CU_JIT_WALL_TIME: output returns the float value of wall clock time, in milliseconds, spent compiling the
 PTX code;<br />
 - CU_JIT_INFO_LOG_BUFFER: input is a pointer to a buffer in which to print any informational log messages
 from PTX assembly;<br />
 - CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES: input is the size in bytes of the buffer; output is the number of
 bytes filled with messages;<br />
 - CU_JIT_ERROR_LOG_BUFFER: input is a pointer to a buffer in which to print any error log messages from
 PTX assembly;<br />
 - CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES: input is the size in bytes of the buffer; output is the number
 of bytes filled with messages;<br />
 - CU_JIT_OPTIMIZATION_LEVEL: input is the level of optimization to apply to generated code (0 - 4), with 4
 being the default and highest level;<br />
 - CU_JIT_TARGET_FROM_CUCONTEXT: causes compilation target to be determined based on current attached
 context (default);<br />
 - CU_JIT_TARGET: input is the compilation target based on supplied CUjit_target_enum; possible values are:<br />
 -– CU_TARGET_COMPUTE_10<br />
 -– CU_TARGET_COMPUTE_11<br />
 -– CU_TARGET_COMPUTE_12<br />
 -– CU_TARGET_COMPUTE_13<br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>phMod</CODE> - - Returned module<DD><CODE>p</CODE> - - Module data to load<DD><CODE>numOptions</CODE> - - Number of options<DD><CODE>options</CODE> - - Options for JIT<DD><CODE>optionValues</CODE> - - Option values for JIT
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,
 CUDA_ERROR_NO_BINARY_FOR_GPU<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><!-- --></A><H3>
cuModuleLoadFatBinary</H3>
<PRE>
public static int <B>cuModuleLoadFatBinary</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;module,
                                        byte[]&nbsp;fatCubin)</PRE>
<DL>
<DD>Loads a fat-binary object.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleLoadFatBinary(CUmodule* mod, const void* fatBin);
 <br />
 <br />
 DESCRIPTION<br />
 Takes a pointer fatBin and loads the corresponding module mod into the current context. The pointer
 represents a fat binary object, which is a collection of different cubin files, all representing the same device
 code but compiled and optimized for different architectures. There is currently no documented API for
 constructing and using fat binary objects by programmers, and therefore this function is an internal function
 in this version of CUDA. More information can be found in the nvcc document.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_NO_BINARY_FOR_GPU,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleUnload(jcuda.driver.CUmodule)"><!-- --></A><H3>
cuModuleUnload</H3>
<PRE>
public static int <B>cuModuleUnload</B>(<A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod)</PRE>
<DL>
<DD>Unloads a module.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleUnload(CUmodule mod);
 <br />
 <br />
 DESCRIPTION<br />
 Unloads a module mod from the current context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetFunction</H3>
<PRE>
public static int <B>cuModuleGetFunction</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                      java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a function handle.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleGetFunction(CUfunction* func, CUmodule mod, const char* funcname);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *func the handle of the function of name funcname located in module mod. If no function of
 that name exists, cuModuleGetFunction() returns CUDA_ERROR_NOT_FOUND.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetGlobal</H3>
<PRE>
public static int <B>cuModuleGetGlobal</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                    int[]&nbsp;bytes,
                                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                    java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns a global pointer from a module.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleGetGlobal(CUdeviceptr* devPtr, unsigned int* bytes, CUmodule mod, const char*
 globalname);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *devPtr and *bytes the base pointer and size of the global of name globalname located in mod-
 ule mod. If no variable of that name exists, cuModuleGetGlobal() returns CUDA_ERROR_NOT_FOUND.
 Both parameters devPtr and bytes are optional. If one of them is null, it is ignored.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuModuleGetTexRef(jcuda.driver.CUtexref, jcuda.driver.CUmodule, java.lang.String)"><!-- --></A><H3>
cuModuleGetTexRef</H3>
<PRE>
public static int <B>cuModuleGetTexRef</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef,
                                    <A HREF="../../jcuda/driver/CUmodule.html" title="class in jcuda.driver">CUmodule</A>&nbsp;hmod,
                                    java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Gets a handle to a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuModuleGetTexRef(CUtexref* texRef, CUmodule hmod, const char* texrefname);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *texref the handle of the texture reference of name texrefname in the module mod. If no tex-
 ture reference of that name exists, cuModuleGetTexRef() returns CUDA_ERROR_NOT_FOUND.
 This texture reference handle should not be destroyed, since it will be destroyed when the module is unloaded.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_NOT_FOUND,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleLoad(jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadData(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadData(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])"><CODE>cuModuleLoadFatBinary(jcuda.driver.CUmodule, byte[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleUnload(jcuda.driver.CUmodule)"><CODE>cuModuleUnload(jcuda.driver.CUmodule)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetFunction(jcuda.driver.CUfunction, jcuda.driver.CUmodule, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)"><CODE>cuModuleGetGlobal(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUmodule, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemGetInfo(int[], int[])"><!-- --></A><H3>
cuMemGetInfo</H3>
<PRE>
public static int <B>cuMemGetInfo</B>(int[]&nbsp;free,
                               int[]&nbsp;total)</PRE>
<DL>
<DD>Gets free and total memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemGetInfo(unsigned int* free, unsigned int* total);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *free and *total respectively, the free and total amount of memory available for allocation by
 the CUDA context, in bytes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostAlloc(jcuda.Pointer, long, int)"><!-- --></A><H3>
cuMemHostAlloc</H3>
<PRE>
public static int <B>cuMemHostAlloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
                                 long&nbsp;bytes,
                                 int&nbsp;Flags)</PRE>
<DL>
<DD>Allocates bytes bytes of host memory that is page-locked and accessible to the device. The driver tracks the virtual
 memory ranges allocated with this function and automatically accelerates calls to functions such as cuMemcpyHtoD().
 Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than
 pageable memory obtained with functions such as malloc(). Allocating excessive amounts of pinned memory may
 degrade system performance, since it reduces the amount of memory available to the system for paging. As a result,
 this function is best used sparingly to allocate staging areas for data exchange between host and device.<br />
 <br />
 The Flags parameter enables different options to be specified that affect the allocation, as follows.
 - CU_MEMHOSTALLOC_PORTABLE: The memory returned by this call will be considered as pinned memory
 by all CUDA contexts, not just the one that performed the allocation.<br />
 - CU_MEMHOSTALLOC_DEVICEMAP: Maps the allocation into the CUDA address space. The device pointer
 to the memory may be obtained by calling cuMemHostGetDevicePointer(). This feature is available only on
 GPUs with compute capability greater than or equal to 1.1.<br />
 - CU_MEMHOSTALLOC_WRITECOMBINED: Allocates the memory as write-combined (WC). WC memory
 can be transferred across the PCI Express bus more quickly on some system configurations, but cannot be read
 efficiently by most CPUs. WC memory is a good option for buffers that will be written by the CPU and read by
 the GPU via mapped pinned memory or host->device transfers.<br />
 <br />
 All of these flags are orthogonal to one another: a developer may allocate memory that is portable, mapped and/or
 write-combined with no restrictions.
 The CUDA context must have been created with the CU_CTX_MAP_HOST flag in order for the CU_MEMHOSTALLOC_MAPPED 
 flag to have any effect.
 The CU_MEMHOSTALLOC_MAPPED flag may be specified on CUDA contexts for devices that do not support
 mapped pinned memory. The failure is deferred to cuMemHostGetDevicePointer() because the memory may be
 mapped into other CUDA contexts via the CU_MEMHOSTALLOC_PORTABLE flag.
 The memory allocated by this function must be freed with cuMemFreeHost().
 <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pp</CODE> - - Returned host pointer to page-locked memory<DD><CODE>bytes</CODE> - - Requested allocation size in bytes<DD><CODE>Flags</CODE> - - Flags for allocation request
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, 
 CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostGetDevicePointer(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><!-- --></A><H3>
cuMemHostGetDevicePointer</H3>
<PRE>
public static int <B>cuMemHostGetDevicePointer</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;ret,
                                            <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p,
                                            int&nbsp;Flags)</PRE>
<DL>
<DD>Passes back the device pointer ret corresponding to the mapped, pinned host buffer p allocated by cuMemHostAlloc.
 cuMemHostGetDevicePointer() will fail if the CU_MEMALLOCHOST_DEVICEMAP flag was not specified at the
 time the memory was allocated, or if the function is called on a GPU that does not support mapped pinned memory.
 Flags provides for future releases. For now, it must be set to 0.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ret</CODE> - - Returned device pointer<DD><CODE>p</CODE> - - Host pointer<DD><CODE>Flags</CODE> - - Options (must be 0)
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, 
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)"><CODE>cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)"><CODE>cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)"><CODE>cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemHostGetFlags(int[], jcuda.Pointer)"><!-- --></A><H3>
cuMemHostGetFlags</H3>
<PRE>
public static int <B>cuMemHostGetFlags</B>(int[]&nbsp;pFlags,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</PRE>
<DL>
<DD>Passes back the flags pFlags that were specified when allocating 
 the pinned host buffer p allocated by cuMemHostAlloc. <br />
 <br />
 cuMemHostGetFlags() will fail if the pointer does not reside in 
 an allocation performed by cuMemAllocHost() or cuMemHostAlloc().
 <br />
 <br />
 Parameters:<br />
 pFlags  - Returned flags word<br />
 p   - Host pointer<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE <br />
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemHostAlloc(jcuda.Pointer, long, int)"><CODE>cuMemHostAlloc(jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuMemAlloc</H3>
<PRE>
public static int <B>cuMemAlloc</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                             int&nbsp;bytesize)</PRE>
<DL>
<DD>Allocates device memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemAlloc(CUdeviceptr* devPtr, unsigned int count);
 <br />
 <br />
 DESCRIPTION<br />
 Allocates count bytes of linear memory on the device and returns in *devPtr a pointer to the allocated
 memory. The allocated memory is suitably aligned for any kind of variable. The memory is not cleared. If
 count is 0, cuMemAlloc() returns CUDA_ERROR_INVALID_VALUE.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><!-- --></A><H3>
cuMemAllocPitch</H3>
<PRE>
public static int <B>cuMemAllocPitch</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                  int[]&nbsp;pPitch,
                                  int&nbsp;WidthInBytes,
                                  int&nbsp;Height,
                                  int&nbsp;ElementSizeBytes)</PRE>
<DL>
<DD>Allocates device memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemAllocPitch(CUdeviceptr* devPtr, unsigned int* pitch, unsigned int widthInBytes,
 unsigned int height, unsigned int elementSizeBytes);
 <br />
 <br />
 DESCRIPTION<br />
 Allocates at least widthInBytes*height bytes of linear memory on the device and returns in *devPtr
 a pointer to the allocated memory. The function may pad the allocation to ensure that corresponding
 pointers in any given row will continue to meet the alignment requirements for coalescing as the address is
 updated from row to row. elementSizeBytes specifies the size of the largest reads and writes that will be
 performed on the memory range. elementSizeBytes may be 4, 8 or 16 (since coalesced memory transactions
 are not possible on other data sizes). If elementSizeBytes is smaller than the actual read/write size of
 a kernel, the kernel will run correctly, but possibly at reduced speed. The pitch returned in *pitch by
 cuMemAllocPitch() is the width in bytes of the allocation. The intended usage of pitch is as a separate
 parameter of the allocation, used to compute addresses within the 2D array. Given the row and column of
 an array element of type T, the address is computed as<br />
 T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;<br />
 The pitch returned by cuMemAllocPitch() is guaranteed to work with cuMemcpy2D() under all cir-
 cumstances. For allocations of 2D arrays, it is recommended that programmers consider performing pitch
 allocations using cuMemAllocPitch(). Due to alignment restrictions in the hardware, this is especially
 true if the application will be performing 2D memory copies between different regions of device memory
 (whether linear memory or CUDA arrays).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ElementSizeBytes</CODE> - Size of biggest r/w to be performed by kernels on this memory: 4, 8 or 16 bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemFree(jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuMemFree</H3>
<PRE>
public static int <B>cuMemFree</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Frees device memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemFree(CUdeviceptr devPtr);
 <br />
 <br />
 DESCRIPTION<br />
 Frees the memory space pointed to by devPtr, which must have been returned by a previous call to
 cuMemMalloc() or cuMemMallocPitch().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><!-- --></A><H3>
cuMemGetAddressRange</H3>
<PRE>
public static int <B>cuMemGetAddressRange</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pbase,
                                       int[]&nbsp;psize,
                                       <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr)</PRE>
<DL>
<DD>Get information on memory allocations.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemGetAddressRange(CUdeviceptr* basePtr, unsigned int* size, CUdeviceptr devPtr);
 <br />
 <br />
 DESCRIPTION<br />
 Returns the base address in *basePtr and size and *size of the allocation by cuMemAlloc() or cuMemAl-
 locPitch() that contains the input pointer devPtr. Both parameters basePtr and size are optional. If
 one of them is null, it is ignored.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemAllocHost(jcuda.Pointer, int)"><!-- --></A><H3>
cuMemAllocHost</H3>
<PRE>
public static int <B>cuMemAllocHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pp,
                                 int&nbsp;bytesize)</PRE>
<DL>
<DD>Allocates page-locked host memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemAllocHost(void** hostPtr, unsigned int count);
 <br />
 <br />
 DESCRIPTION<br />
 Allocates count bytes of host memory that is page-locked and accessible to the device. The driver tracks
 the virtual memory ranges allocated with this function and automatically accelerates calls to functions such
 as cuMemcpy(). Since the memory can be accessed directly by the device, it can be read or written
 with much higher bandwidth than pageable memory obtained with functions such as malloc(). Allocating
 excessive amounts of memory with cuMemAllocHost() may degrade system performance, since it reduces
 the amount of memory available to the system for paging. As a result, this function is best used sparingly
 to allocate staging areas for data exchange between host and device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemFreeHost(jcuda.Pointer)"><!-- --></A><H3>
cuMemFreeHost</H3>
<PRE>
public static int <B>cuMemFreeHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;p)</PRE>
<DL>
<DD>Frees page-locked host memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemFreeHost(void* hostPtr);
 <br />
 <br />
 DESCRIPTION<br />
 Frees the memory space pointed to by hostPtr, which must have been returned by a previous call to
 cuMemAllocHost().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><!-- --></A><H3>
cuMemcpyHtoD</H3>
<PRE>
public static int <B>cuMemcpyHtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copy memory from Host to Device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyHtoD(CUdeviceptr dstDevPtr, const void *srcHostPtr, unsigned int count);<br />
 CUresult cuMemcpyHtoDAsync(CUdeviceptr dstDevPtr, const void *srcHostPtr, unsigned int count,
 CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from host memory to device memory. dstDevPtr and srcHostPtr specify the base addresses of
 the destination and source, respectively. count specifies the number of bytes to copy.
 cuMemcpyHtoDAsync() is asynchronous and can optionally be associated to a stream by passing a non-
 zero stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuMemcpyDtoH</H3>
<PRE>
public static int <B>cuMemcpyDtoH</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Host.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyDtoH(void* dstHostPtr, CUdeviceptr srcDevPtr, unsigned int count);<br />
 CUresult cuMemcpyDtoHAsync(void* dstHostPtr, CUdeviceptr srcDevPtr, unsigned int count, CUstream
 stream);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from device to host memory. dstHostPtr and srcDevPtrspecify the base addresses of the source
 and destination, respectively. countspecifies the number of bytes to copy.
 MemcpyDtoHAsync() is asynchronous and can optionally be associated to a stream by passing a non-zero
 stream argument. It only works on page-locked host memory and returns an error if a pointer to pageable
 memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuMemcpyDtoD</H3>
<PRE>
public static int <B>cuMemcpyDtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyDtoD(CUdeviceptr dstDevPtr, CUdeviceptr srcDevPtr, unsigned int count);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from device memory to device memory. dstDevice and srcDevPtr are the base pointers of the
 destination and source, respectively. count specifies the number of bytes to copy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuMemcpyDtoA</H3>
<PRE>
public static int <B>cuMemcpyDtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               int&nbsp;dstIndex,
                               <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Device to Array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyDtoA(CUarray dstArray, unsigned int dstIndex, CUdeviceptr srcDevPtr, unsigned
 int count);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from device memory to a 1D CUDA array. dstArray and dstIndex specify the CUDA array handle
 and starting index of the destination data. srcDevPtr specifies the base pointer of the source. count
 specifies the number of bytes to copy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><!-- --></A><H3>
cuMemcpyAtoD</H3>
<PRE>
public static int <B>cuMemcpyAtoD</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hSrc,
                               int&nbsp;SrcIndex,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Device.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyAtoD(CUdeviceptr dstDevPtr, CUarray srcArray, unsigned int srcIndex, unsigned
 int count);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from a 1D CUDA array to device memory. dstDevPtr specifies the base pointer of the destination
 and must be naturally aligned with the CUDA array elements. srcArray and srcIndex specify the CUDA
 array handle and the index (in array elements) of the array element where the copy is to begin. count
 specifies the number of bytes to copy and must be evenly divisible by the array element size.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><!-- --></A><H3>
cuMemcpyHtoA</H3>
<PRE>
public static int <B>cuMemcpyHtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               int&nbsp;dstIndex,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Host to Array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyHtoA(CUarray dstArray, unsigned int dstIndex, const void *srcHostPtr, unsigned
 int count);<br />
 CUresult cuMemcpyHtoAAsync(CUarray dstArray, unsigned int dstIndex, const void *srcHostPtr,
 unsigned int count, CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from host memory to a 1D CUDA array. dstArray and dstIndex specify the CUDA array handle
 and starting index of the destination data. srcHostPtr specify the base addresse of the source. count
 specifies the number of bytes to copy.
 cuMemcpyHtoAAsync() is asynchronous and can optionally be associated to a stream by passing a non-
 zero stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><!-- --></A><H3>
cuMemcpyAtoH</H3>
<PRE>
public static int <B>cuMemcpyAtoH</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                               int&nbsp;srcIndex,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Host.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyAtoH(void* dstHostPtr, CUarray srcArray, unsigned int srcIndex, unsigned int
 count);<br />
 CUresult cuMemcpyAtoHAsync(void* dstHostPtr, CUarray srcArray, unsigned int srcIndex, unsigned
 int count, CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from a 1D CUDA array to host memory. dstHostPtr specifies the base pointer of the destination.
 srcArray and srcIndex specify the CUDA array handle and starting index of the source data. count
 specifies the number of bytes to copy.
 cuMemcpyAtoHAsync() is asynchronous and can optionally be associated to a stream by passing a nonzero
 stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><!-- --></A><H3>
cuMemcpyAtoA</H3>
<PRE>
public static int <B>cuMemcpyAtoA</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                               int&nbsp;dstIndex,
                               <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                               int&nbsp;srcIndex,
                               int&nbsp;ByteCount)</PRE>
<DL>
<DD>Copies memory from Array to Array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpyAtoA(CUarray dstArray, unsigned int dstIndex, CUarray srcArray, unsigned int
 srcIndex, unsigned int count);
 <br />
 <br />
 DESCRIPTION<br />
 Copies from one 1D CUDA array to another. dstArray and srcArray specify the handles of the destination
 and source CUDA arrays for the copy, respectively. dstIndex and srcIndex specify the destination and
 source indices into the CUDA array. These values are in the range [0, Width-1] for the CUDA array; they
 are not byte offsets. count is the number of bytes to be copied. The size of the elements in the CUDA arrays
 need not be the same format, but the elements must be the same size; and count must be evenly divisible
 by that size.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><!-- --></A><H3>
cuMemcpy2D</H3>
<PRE>
public static int <B>cuMemcpy2D</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory for 2D arrays.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpy2D(const CUDA_MEMCPY2D* copyParam);<br />
 CUresult cuMemcpy2DUnaligned(const CUDA_MEMCPY2D* copyParam);<br />
 CUresult cuMemcpy2DAsync(const CUDA_MEMCPY2D* copyParam, CUstream stream);<br />
 <br />
 <br />
 DESCRIPTION<br />
 Perform a 2D memory copy according to the parameters specified in copyParam. The CUDA_MEMCPY2D
 structure is defined as such:
 <pre>
 typedef struct CUDA_MEMCPY2D_st {
     unsigned int srcXInBytes, srcY;
     CUmemorytype srcMemoryType;
     const void *srcHost;
     CUdeviceptr srcDevice;
     CUarray srcArray;
     unsigned int srcPitch;
     unsigned int dstXInBytes, dstY;
     CUmemorytype dstMemoryType;
     void *dstHost;
     CUdeviceptr dstDevice;
     CUarray dstArray;
     unsigned int dstPitch;
     unsigned int WidthInBytes;
     unsigned int Height;
 } CUDA_MEMCPY2D;
 </pre>
 where:
 - srcMemoryType and dstMemoryType specify the type of memory of the source and destination,
 respectively; CUmemorytype_enum is defined as such:
 <pre>
 typedef enum CUmemorytype_enum {
     CU_MEMORYTYPE_HOST = 0x01,
     CU_MEMORYTYPE_DEVICE = 0x02,
     CU_MEMORYTYPE_ARRAY = 0x03
 } CUmemorytype;
 </pre>
 If srcMemoryType is CU_MEMORYTYPE_HOST, srcHost and srcPitch specify the (host)
 base address of the source data and the bytes per row to apply. srcArray is ignored.<br />
 If srcMemoryType is CU_MEMORYTYPE_DEVICE, srcDevice and srcPitch specify the
 (device) base address of the source data and the bytes per row to apply. srcArray is ignored.<br />
 If srcMemoryType is CU_MEMORYTYPE_ARRAY, srcArray specifies the handle of the
 source data. srcHost, srcDevice and srcPitch are ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_HOST, dstHost and dstPitch specify the (host)
 base address of the destination data and the bytes per row to apply. dstArray is ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_DEVICE, dstDevice and dstPitch specify the
 (device) base address of the destination data and the bytes per row to apply. dstArray is ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_ARRAY, dstArray specifies the handle of the
 destination data. dstHost, dstDevice and dstPitch are ignored.<br />
 - srcXInBytes and srcY specify the base address of the source data for the copy.
 For host pointers, the starting address is<br />
 void* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);<br />
 For device pointers, the starting address is<br />
 CUdeviceptr Start = srcDevice+srcY*srcPitch+srcXInBytes;
 For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.<br />
 - dstXInBytes and dstY specify the base address of the destination data for the copy.
 For host pointers, the base address is<br />
 void* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);<br />
 For device pointers, the starting address is<br />
 CUdeviceptr dstStart = dstDevice+dstY*dstPitch+dstXInBytes;<br />
 For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.<br />
 - WidthInBytes and Height specify the width (in bytes) and height of the 2D copy being performed.
 Any pitches must be greater than or equal to WidthInBytes.<br />
 cuMemcpy2D() returns an error if any pitch is greater than the maximum allowed (CU_DEVICE_ATTRIBUTE_MAX_PITCH)
 cuMemAllocPitch() passes back pitches that always work with cuMemcpy2D(). On intra-device
 memory copies (device - device, CUDA array - device, CUDA array - CUDA array), cuMemcpy2D()
 may fail for pitches not computed by cuMemAllocPitch(). cuMemcpy2DUnaligned()
 does not have this restriction, but may run significantly slower in the cases where cuMemcpy2D()
 would have returned an error code.
 cuMemcpy2DAsync() is asynchronous and can optionally be associated to a stream by passing a
 non-zero stream argument. It only works on page-locked host memory and returns an error if a pointer
 to pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, 168, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><CODE>cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2DUnaligned(jcuda.driver.CUDA_MEMCPY2D)"><!-- --></A><H3>
cuMemcpy2DUnaligned</H3>
<PRE>
public static int <B>cuMemcpy2DUnaligned</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><!-- --></A><H3>
cuMemcpy3D</H3>
<PRE>
public static int <B>cuMemcpy3D</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy)</PRE>
<DL>
<DD>Copies memory for 3D arrays.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemcpy3D(const CUDA_MEMCPY3D* copyParam);<br />
 CUresult cuMemcpy3DAsync(const CUDA_MEMCPY3D* copyParam, CUstream stream);<br />
 <br />
 <br />
 DESCRIPTION<br />
 Perform a 3D memory copy according to the parameters specified in copyParam. The CUDA_MEMCPY3D
 structure is defined as such:
 <pre>
 typedef struct CUDA_MEMCPY3D_st {
     unsigned int srcXInBytes, srcY, srcZ;
     unsigned int srcLOD;
     CUmemorytype srcMemoryType;
     const void *srcHost;
     CUdeviceptr srcDevice;
     CUarray srcArray;
     unsigned int srcPitch; // ignored when src is array
     unsigned int srcHeight; // ignored when src is array; may be 0 if Depth==1
     unsigned int dstXInBytes, dstY, dstZ;
     unsigned int dstLOD;
     CUmemorytype dstMemoryType;
     void *dstHost;
     CUdeviceptr dstDevice;
     CUarray dstArray;
     unsigned int dstPitch; // ignored when dst is array
     unsigned int dstHeight; // ignored when dst is array; may be 0 if Depth==1
     unsigned int WidthInBytes;
     unsigned int Height;
     unsigned int Depth;
 } CUDA_MEMCPY3D;
 </pre>
 CUresult CUDAAPI cuMemcpy3D( const CUDA_MEMCPY3D *pCopy );
 where:
 - srcMemoryType and dstMemoryType specify the type of memory of the source and destination,
 respectively; CUmemorytype_enum is defined as such:
 <pre>
 typedef enum CUmemorytype_enum {
     CU_MEMORYTYPE_HOST = 0x01,
     CU_MEMORYTYPE_DEVICE = 0x02,
     CU_MEMORYTYPE_ARRAY = 0x03
 } CUmemorytype;
 </pre>
 If srcMemoryType is CU_MEMORYTYPE_HOST, srcHost, srcPitch and srcHeight specify
 the (host) base address of the source data, the bytes per row, and the height of each 2D slice of the
 3D array. srcArray is ignored.<br />
 If srcMemoryType is CU_MEMORYTYPE_DEVICE, srcDevice, srcPitch and srcHeight
 specify the (device) base address of the source data, the bytes per row, and the height of each 2D slice
 of the 3D array. srcArray is ignored.<br />
 If srcMemoryType is CU_MEMORYTYPE_ARRAY, srcArray specifies the handle of the
 source data. srcHost, srcDevice, srcPitch and srcHeight are ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_HOST, dstHost and dstPitch specify the (host)
 base address of the destination data, the bytes per row, and the height of each 2D slice of the 3D array.
 dstArray is ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_DEVICE, dstDevice and dstPitch specify the
 (device) base address of the destination data, the bytes per row, and the height of each 2D slice of the
 3D array. dstArray is ignored.<br />
 If dstMemoryType is CU_MEMORYTYPE_ARRAY, dstArray specifies the handle of the
 destination data. dstHost, dstDevice, dstPitch and dstHeight are ignored.<br />
 - srcXInBytes, srcY and srcZ specify the base address of the source data for the copy.
 For host pointers, the starting address is<br />
 void* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch + srcXInBytes);<br />
 For device pointers, the starting address is<br />
 CUdeviceptr Start = srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;<br />
 For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.<br />
 - dstXInBytes, dstY and dstZ specify the base address of the destination data for the copy.
 For host pointers, the base address is<br />
 void* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch + dstXInBytes);<br />
 For device pointers, the starting address is<br />
 CUdeviceptr dstStart = dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;<br />
 For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.<br />
 - WidthInBytes, Height and Depth specify the width (in bytes), height and depth of the 3D copy
 being performed. Any pitches must be greater than or equal to WidthInBytes.<br />
 cuMemcpy3D() returns an error if any pitch is greater than the maximum allowed (CU_DEVICE_ATTRIBUTE_MAX_PITCH)
 cuMemcpy3DAsync() is asynchronous and can optionally be associated to a stream by passing a
 non-zero stream argument. It only works on page-locked host memory and returns an error if a pointer
 to pageable memory is passed as input.
 The srcLOD and dstLOD members of the CUDA_MEMCPY3D structure must be set to 0.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoA(jcuda.driver.CUarray, int, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoA(jcuda.driver.CUarray, int, jcuda.driver.CUarray, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><CODE>cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoDAsync(jcuda.driver.CUdeviceptr, jcuda.Pointer, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyHtoDAsync</H3>
<PRE>
public static int <B>cuMemcpyHtoDAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;srcHost,
                                    int&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)"><CODE>cuMemcpyHtoD(jcuda.driver.CUdeviceptr, jcuda.Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoHAsync(jcuda.Pointer, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyDtoHAsync</H3>
<PRE>
public static int <B>cuMemcpyDtoHAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                                    int&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoH(jcuda.Pointer, jcuda.driver.CUdeviceptr, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyDtoDAsync(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyDtoDAsync</H3>
<PRE>
public static int <B>cuMemcpyDtoDAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                    <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;srcDevice,
                                    int&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)"><CODE>cuMemcpyDtoD(jcuda.driver.CUdeviceptr, jcuda.driver.CUdeviceptr, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyHtoAAsync(jcuda.driver.CUarray, int, jcuda.Pointer, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyHtoAAsync</H3>
<PRE>
public static int <B>cuMemcpyHtoAAsync</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;dstArray,
                                    int&nbsp;dstIndex,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pSrc,
                                    int&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)"><CODE>cuMemcpyHtoA(jcuda.driver.CUarray, int, jcuda.Pointer, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpyAtoHAsync(jcuda.Pointer, jcuda.driver.CUarray, int, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpyAtoHAsync</H3>
<PRE>
public static int <B>cuMemcpyAtoHAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dstHost,
                                    <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;srcArray,
                                    int&nbsp;srcIndex,
                                    int&nbsp;ByteCount,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)"><CODE>cuMemcpyAtoH(jcuda.Pointer, jcuda.driver.CUarray, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy2DAsync(jcuda.driver.CUDA_MEMCPY2D, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpy2DAsync</H3>
<PRE>
public static int <B>cuMemcpy2DAsync</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY2D.html" title="class in jcuda.driver">CUDA_MEMCPY2D</A>&nbsp;pCopy,
                                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)"><CODE>cuMemcpy2D(jcuda.driver.CUDA_MEMCPY2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemcpy3DAsync(jcuda.driver.CUDA_MEMCPY3D, jcuda.driver.CUstream)"><!-- --></A><H3>
cuMemcpy3DAsync</H3>
<PRE>
public static int <B>cuMemcpy3DAsync</B>(<A HREF="../../jcuda/driver/CUDA_MEMCPY3D.html" title="class in jcuda.driver">CUDA_MEMCPY3D</A>&nbsp;pCopy,
                                  <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Copies memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)"><CODE>cuMemcpy3D(jcuda.driver.CUDA_MEMCPY3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><!-- --></A><H3>
cuMemsetD8</H3>
<PRE>
public static int <B>cuMemsetD8</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                             char&nbsp;uc,
                             int&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemsetD8(CUdeviceptr dstDevPtr, unsigned char value, unsigned int count );<br />
 CUresult cuMemsetD16(CUdeviceptr dstDevPtr, unsigned short value, unsigned int count );<br />
 CUresult cuMemsetD32(CUdeviceptr dstDevPtr, unsigned int value, unsigned int count );<br />
 <br />
 DESCRIPTION<br />
 Sets the memory range of count 8-, 16-, or 32-bit values to the specified value value.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><!-- --></A><H3>
cuMemsetD16</H3>
<PRE>
public static int <B>cuMemsetD16</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                              short&nbsp;us,
                              int&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><!-- --></A><H3>
cuMemsetD32</H3>
<PRE>
public static int <B>cuMemsetD32</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                              int&nbsp;ui,
                              int&nbsp;N)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><!-- --></A><H3>
cuMemsetD2D8</H3>
<PRE>
public static int <B>cuMemsetD2D8</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                               int&nbsp;dstPitch,
                               char&nbsp;uc,
                               int&nbsp;Width,
                               int&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuMemsetD2D8(CUdeviceptr dstDevPtr, unsigned int dstPitch, unsigned char value, unsigned
 int width, unsigned int height );<br />
 CUresult cuMemsetD2D16(CUdeviceptr dstDevPtr, unsigned int dstPitch, unsigned short value,
 unsigned int width, unsigned int height );<br />
 CUresult cuMemsetD2D32(CUdeviceptr dstDevPtr, unsigned int dstPitch, unsigned int value, unsigned
 int width, unsigned int height );<br />
 <br />
 DESCRIPTION<br />
 Sets the 2D memory range of width 8-, 16-, or 32-bit values to the specified value value. height specifies
 the number of rows to set, and dstPitch specifies the number of bytes between each row. These functions
 perform fastest when the pitch is one that has been passed back by cuMemAllocPitch().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><!-- --></A><H3>
cuMemsetD2D16</H3>
<PRE>
public static int <B>cuMemsetD2D16</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                int&nbsp;dstPitch,
                                short&nbsp;us,
                                int&nbsp;Width,
                                int&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><!-- --></A><H3>
cuMemsetD2D32</H3>
<PRE>
public static int <B>cuMemsetD2D32</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dstDevice,
                                int&nbsp;dstPitch,
                                int&nbsp;ui,
                                int&nbsp;Width,
                                int&nbsp;Height)</PRE>
<DL>
<DD>Initializes device memory.
 <br />
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><!-- --></A><H3>
cuFuncGetAttribute</H3>
<PRE>
public static int <B>cuFuncGetAttribute</B>(int[]&nbsp;pi,
                                     int&nbsp;attrib,
                                     <A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;func)</PRE>
<DL>
<DD>Returns in pi the integer value of the attribute attrib on the kernel given by func. The supported attributes are:<br />
 - CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: The number of threads beyond which a launch
 of the function would fail. This number depends on both the function and the device on which the function is
 currently loaded.<br />
 - CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: The size in bytes of statically-allocated shared memory
 required by this function. This does not include dynamically-allocated shared memory requested by the user at
 runtime.<br />
 • CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: The size in bytes of user-allocated constant memory required
 by this function.<br />
 • CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: The size in bytes of thread local memory used by this function.<br />
 • CU_FUNC_ATTRIBUTE_NUM_REGS: The number of registers used by each thread of this function.<br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pi</CODE> - - Returned attribute value<DD><CODE>attrib</CODE> - - Attribute requested<DD><CODE>func</CODE> - - Function to query attribute of
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, 
 CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><!-- --></A><H3>
cuFuncSetBlockShape</H3>
<PRE>
public static int <B>cuFuncSetBlockShape</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      int&nbsp;x,
                                      int&nbsp;y,
                                      int&nbsp;z)</PRE>
<DL>
<DD>Sets the block-dimensions for the function.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuFuncSetBlockShape(CUfunction func, int x, int y, int z);
 <br />
 <br />
 DESCRIPTION<br />
 Specifies the X, Y and Z dimensions of the thread blocks that are created when the kernel given by func is
 launched.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuFuncSetSharedSize</H3>
<PRE>
public static int <B>cuFuncSetSharedSize</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                      int&nbsp;bytes)</PRE>
<DL>
<DD>Sets the shared-memory size for the function.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuFuncSetSharedSize(CUfunction func, unsigned int bytes);
 <br />
 <br />
 DESCRIPTION<br />
 Sets through bytes the amount of shared memory that will be available to each thread block when the kernel
 given by func is launched.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuFuncSetCacheConfig(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuFuncSetCacheConfig</H3>
<PRE>
public static int <B>cuFuncSetCacheConfig</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                       int&nbsp;config)</PRE>
<DL>
<DD>Sets the preferred cache configuration for the device function hfunc.<br />
 <br />
 On devices where the L1 cache and shared memory use the same hardware 
 resources, this sets through config the preferred cache configuration 
 for the device function hfunc. This is only a preference. The driver 
 will use the requested configuration if possible, but it is free to 
 choose a different configuration if required to execute hfunc.
 <br />
 This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.<br />
 <br />
 Switching between configuration modes may insert a device-side synchronization point for streamed kernel launches.<br />
 <br />
 The supported cache modes are:<br />
 <br /> 
 CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)<br />
 CU_FUNC_CACHE_PREFER_SHARED: function prefers larger shared memory and smaller L1 cache.<br />
 CU_FUNC_CACHE_PREFER_L1: function prefers larger L1 cache and smaller shared memory.<br />
 <br />
 <br />
 Parameters:<br />
 hfunc   - Kernel to configure cache for<br />
 config  - Requested cache configuration<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)"><CODE>cuFuncGetAttribute(int[], int, jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><CODE>cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><!-- --></A><H3>
cuArrayCreate</H3>
<PRE>
public static int <B>cuArrayCreate</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                                <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pAllocateArray)</PRE>
<DL>
<DD>Creates a 1D or 2D CUDA array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuArrayCreate(CUarray* array, const CUDA_ARRAY_DESCRIPTOR* desc);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a CUDA array according to the CUDA_ARRAY_DESCRIPTOR structure desc and returns a
 handle to the new CUDA array in *array. The CUDA_ARRAY_DESCRIPTOR structure is defined
 as such:
 <pre>
 typedef struct {
     unsigned int Width;
     unsigned int Height;
     CUarray_format Format;
     unsigned int NumChannels;
 } CUDA_ARRAY_DESCRIPTOR;
 </pre>
 where:
 - Width and Height are the width and height of the CUDA array (in elements); the CUDA array is
 one-dimensional if height is 0, two-dimensional, otherwise;
 - NumChannels specifies the number of packed components per CUDA array element.; it may be 1, 2
 or 4;
 - Format specifies the format of the elements; CUarray_format is defined as such:
 <pre>
 typedef enum CUarray_format_enum {
     CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
     CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
     CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
     CU_AD_FORMAT_SIGNED_INT8 = 0x08,
     CU_AD_FORMAT_SIGNED_INT16 = 0x09,
     CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
     CU_AD_FORMAT_HALF = 0x10,
     CU_AD_FORMAT_FLOAT = 0x20
 } CUarray_format;
 </pre>
 Here are examples of CUDA array descriptions:
 - Description for a CUDA array of 2048 floats:
 <pre>
 CUDA_ARRAY_DESCRIPTOR desc;
 desc.Format = CU_AD_FORMAT_FLOAT;
 desc.NumChannels = 1;
 desc.Width = 2048;
 desc.Height = 1;
 </pre>
 - Description for a 64 x 64 CUDA array of floats:
 <pre>
 CUDA_ARRAY_DESCRIPTOR desc;
 desc.Format = CU_AD_FORMAT_FLOAT;
 desc.NumChannels = 1;
 desc.Width = 64;
 desc.Height = 64;
 </pre>
 - Description for a width x height CUDA array of 64-bit, 4x16-bit float16’s:
 <pre>
 CUDA_ARRAY_DESCRIPTOR desc;
 desc.FormatFlags = CU_AD_FORMAT_HALF;
 desc.NumChannels = 4;
 desc.Width = width;
 desc.Height = height;
 </pre>
 - Description for a width x height CUDA array of 16-bit elements, each of which is two 8-bit unsigned
 chars:
 <pre>
 CUDA_ARRAY_DESCRIPTOR arrayDesc;
 desc.FormatFlags = CU_AD_FORMAT_UNSIGNED_INTS;
 desc.NumChannels = 2;
 desc.Width = width;
 desc.Height = height;
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><!-- --></A><H3>
cuArrayGetDescriptor</H3>
<PRE>
public static int <B>cuArrayGetDescriptor</B>(<A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                                       <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Get a 1D or 2D CUDA array descriptor.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuArrayGetDescriptor(CUDA_ARRAY_DESCRIPTOR* arrayDesc, CUarray array)
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *arrayDesc a descriptor of the format and dimensions of the 1D or 2D CUDA array array. It is
 useful for subroutines that have been passed a CUDA array, but need to know the CUDA array parameters
 for validation or other purposes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArrayDestroy(jcuda.driver.CUarray)"><!-- --></A><H3>
cuArrayDestroy</H3>
<PRE>
public static int <B>cuArrayDestroy</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Destroys a CUDA array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuArrayDestroy(CUarray array);
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the CUDA array array.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_ARRAY_IS_MAPPED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)"><CODE>cuMemsetD8(jcuda.driver.CUdeviceptr, char, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)"><CODE>cuMemsetD16(jcuda.driver.CUdeviceptr, short, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)"><CODE>cuMemsetD32(jcuda.driver.CUdeviceptr, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)"><CODE>cuMemsetD2D8(jcuda.driver.CUdeviceptr, int, char, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)"><CODE>cuMemsetD2D16(jcuda.driver.CUdeviceptr, int, short, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)"><CODE>cuMemsetD2D32(jcuda.driver.CUdeviceptr, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><!-- --></A><H3>
cuArray3DCreate</H3>
<PRE>
public static int <B>cuArray3DCreate</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pHandle,
                                  <A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pAllocateArray)</PRE>
<DL>
<DD>Creates a CUDA array.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuArray3DCreate(CUarray* array, const CUDA_ARRAY3D_DESCRIPTOR* desc);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a CUDA array according to the CUDA_ARRAY3D_DESCRIPTOR structure desc and re-
 turns a handle to the new CUDA array in *array. The CUDA_ARRAY3D_DESCRIPTOR structure
 is defined as such:
 <pre>
 typedef struct {
     unsigned int Width;
     unsigned int Height;
     unsigned int Depth;
     CUarray_format Format;
     unsigned int NumChannels;
     unsigned int Flags;
 } CUDA_ARRAY3D_DESCRIPTOR;
 </pre>
 where:
 - Width, Height and Depth are the width, height and depth of the CUDA array (in elements); the
 CUDA array is one-dimensional if height and depth are 0, two-dimensional if depth is 0, and three-
 dimensional otherwise;
 - NumChannels specifies the number of packed components per CUDA array element.; it may be 1, 2
 or 4;
 - Format specifies the format of the elements; CUarray_format is defined as such:
 <pre>
 typedef enum CUarray_format_enum {
     CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
     CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
     CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
     CU_AD_FORMAT_SIGNED_INT8 = 0x08,
     CU_AD_FORMAT_SIGNED_INT16 = 0x09,
     CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
     CU_AD_FORMAT_HALF = 0x10,
     CU_AD_FORMAT_FLOAT = 0x20
 } CUarray_format;
 </pre>
 - Flags provides for future features. For now, it must be set to 0.
 Here are examples of CUDA array descriptions:
 - Description for a CUDA array of 2048 floats:
 <pre>
 CUDA_ARRAY3D_DESCRIPTOR desc;
 desc.Format = CU_AD_FORMAT_FLOAT;
 desc.NumChannels = 1;
 desc.Width = 2048;
 desc.Height = 0;
 desc.Depth = 0;
 </pre>
 - Description for a 64 x 64 CUDA array of floats:
 <pre>
 CUDA_ARRAY3D_DESCRIPTOR desc;
 desc.Format = CU_AD_FORMAT_FLOAT;
 desc.NumChannels = 1;
 desc.Width = 64;
 desc.Height = 64;
 desc.Depth = 0;
 </pre>
 - Description for a width x height x depth CUDA array of 64-bit, 4x16-bit float16’s:
 <pre>
 CUDA_ARRAY_DESCRIPTOR desc;
 desc.FormatFlags = CU_AD_FORMAT_HALF;
 desc.NumChannels = 4;
 desc.Width = width;
 desc.Height = height;
 desc.Depth = depth;
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY, CUDA_ERROR_UNKNOWN,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetInfo(int[], int[])"><CODE>cuMemGetInfo(int[], int[])</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAlloc(jcuda.driver.CUdeviceptr, int)"><CODE>cuMemAlloc(jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)"><CODE>cuMemAllocPitch(jcuda.driver.CUdeviceptr, int[], int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFree(jcuda.driver.CUdeviceptr)"><CODE>cuMemFree(jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemAllocHost(jcuda.Pointer, int)"><CODE>cuMemAllocHost(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemFreeHost(jcuda.Pointer)"><CODE>cuMemFreeHost(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)"><CODE>cuMemGetAddressRange(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUdeviceptr)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuArray3DGetDescriptor(jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR, jcuda.driver.CUarray)"><!-- --></A><H3>
cuArray3DGetDescriptor</H3>
<PRE>
public static int <B>cuArray3DGetDescriptor</B>(<A HREF="../../jcuda/driver/CUDA_ARRAY3D_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY3D_DESCRIPTOR</A>&nbsp;pArrayDescriptor,
                                         <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray)</PRE>
<DL>
<DD>Get a 3D CUDA array descriptor.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuArray3DGetDescriptor(CUDA_ARRAY3D_DESC *arrayDesc, CUarray array);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *arrayDesc a descriptor containing information on the format and dimensions of the CUDA
 array array. It is useful for subroutines that have been passed a CUDA array, but need to know the CUDA
 array parameters for validation or other purposes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)"><CODE>cuArrayCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)"><CODE>cuArray3DCreate(jcuda.driver.CUarray, jcuda.driver.CUDA_ARRAY3D_DESCRIPTOR)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)"><CODE>cuArrayGetDescriptor(jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUarray)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuArrayDestroy(jcuda.driver.CUarray)"><CODE>cuArrayDestroy(jcuda.driver.CUarray)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefCreate(jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefCreate</H3>
<PRE>
public static int <B>cuTexRefCreate</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;pTexRef)</PRE>
<DL>
<DD>Creates a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefCreate(CUtexref* texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a texture reference and returns its handle in *texRef. Once created, the application must call
 cuTexRefSetArray() or cuTexRefSetAddress() to associate the reference with allocated memory. Other
 texture reference functions are used to specify the format and interpretation (addressing, filtering, etc.) to
 be used when the memory is read through this texture reference. To associate the texture reference with a
 texture ordinal for a given function, the application should call cuParamSetTexRef().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefDestroy(jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefDestroy</H3>
<PRE>
public static int <B>cuTexRefDestroy</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Destroys a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefDestroy(CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the texture reference.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><!-- --></A><H3>
cuTexRefSetArray</H3>
<PRE>
public static int <B>cuTexRefSetArray</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                   <A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;hArray,
                                   int&nbsp;Flags)</PRE>
<DL>
<DD>Binds an array to a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetArray(CUtexref texRef, CUarray array, unsigned int flags);
 <br />
 <br />
 DESCRIPTION<br />
 Binds the CUDA array array to the texture reference texRef. Any previous address or CUDA ar-
 ray state associated with the texture reference is superseded by this function. flags must be set to
 CU_TRSA_OVERRIDE_FORMAT. Any CUDA array previously bound to texRef is unbound.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuTexRefSetAddress</H3>
<PRE>
public static int <B>cuTexRefSetAddress</B>(int[]&nbsp;ByteOffset,
                                     <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                     <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                     int&nbsp;bytes)</PRE>
<DL>
<DD>Binds an address as a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetAddress(unsigned int* byteOffset, CUtexref texRef, CUdeviceptr devPtr,
 int bytes);
 <br />
 <br />
 DESCRIPTION<br />
 Binds a linear address range to the texture reference texRef. Any previous address or CUDA array state
 associated with the texture reference is superseded by this function. Any memory previously bound to
 texRef is unbound.
 Since the hardware enforces an alignment requirement on texture base addresses, cuTexRefSetAddress()
 passes back a byte offset in *byteOffset that must be applied to texture fetches in order to read from the
 desired memory. This offset must be divided by the texel size and passed to kernels that read from the
 texture so they can be applied to the tex1Dfetch() function.
 If the device memory pointer was returned from cuMemAlloc(), the offset is guaranteed to be 0 and NULL
 may be passed as the ByteOffset parameter.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><!-- --></A><H3>
cuTexRefSetFormat</H3>
<PRE>
public static int <B>cuTexRefSetFormat</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                    int&nbsp;fmt,
                                    int&nbsp;NumPackedComponents)</PRE>
<DL>
<DD>Sets the format for a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetFormat(CUtexref texRef, CUarray_format format, int numPackedComponents)
 <br />
 <br />
 DESCRIPTION<br />
 Specifies the format of the data to be read by the texture reference texRef. format and numPackedCom-
 ponents are exactly analogous to the Format and NumChannels members of the CUDA_ARRAY_DESCRIPTOR
 structure: They specify the format of each component and the number of components per array element.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddress2D(jcuda.driver.CUtexref, jcuda.driver.CUDA_ARRAY_DESCRIPTOR, jcuda.driver.CUdeviceptr, int)"><!-- --></A><H3>
cuTexRefSetAddress2D</H3>
<PRE>
public static int <B>cuTexRefSetAddress2D</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                       <A HREF="../../jcuda/driver/CUDA_ARRAY_DESCRIPTOR.html" title="class in jcuda.driver">CUDA_ARRAY_DESCRIPTOR</A>&nbsp;desc,
                                       <A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                       int&nbsp;PitchInBytes)</PRE>
<DL>
<DD>Binds a linear address range to the texture reference hTexRef. Any previous address or CUDA array state associated
 with the texture reference is superseded by this function. Any memory previously bound to hTexRef is unbound.
 When using a tex2D() function inside a kernel, we have to either call cuTexRefSetArray() to bind the corresponding
 texture reference to an array, or cuTexRefSetAddress2D() to bind the texture reference to linear memory.
 Function calls to cuTexRefSetFormat() cannot follow calls to cuTexRefSetAddress2D() for the same texture reference.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hTexRef</CODE> - - Texture reference to bind<DD><CODE>desc</CODE> - - Descriptor of CUDA array<DD><CODE>dptr</CODE> - - Device pointer to bind<DD><CODE>PitchInBytes</CODE> - - Line pitch in bytes
<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, 
 CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><!-- --></A><H3>
cuTexRefSetAddressMode</H3>
<PRE>
public static int <B>cuTexRefSetAddressMode</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                         int&nbsp;dim,
                                         int&nbsp;am)</PRE>
<DL>
<DD>Set the addressing mode for a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetAddressMode(CUtexref texRef, int dim, CUaddress_mode mode);
 <br />
 <br />
 DESCRIPTION<br />
 Specifies the addressing mode mode for the given dimension of the texture reference texRef. If dim is
 zero, the addressing mode is applied to the first parameter of the functions used to fetch from the texture;
 if dim is 1, the second, and so on. CUaddress_mode is defined as such:
 <pre>
 typedef enum CUaddress_mode_enum {
     CU_TR_ADDRESS_MODE_WRAP = 0,
     CU_TR_ADDRESS_MODE_CLAMP = 1,
     CU_TR_ADDRESS_MODE_MIRROR = 2,
 } CUaddress_mode;
 </pre>
 Note that this call has no effect if texRef is bound to linear memory.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetFilterMode</H3>
<PRE>
public static int <B>cuTexRefSetFilterMode</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                        int&nbsp;fm)</PRE>
<DL>
<DD>Sets the mode for a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetFilterMode(CUtexref texRef, CUfilter_mode mode);
 <br />
 <br />
 DESCRIPTION<br />
 Specifies the filtering mode mode to be used when reading memory through the texture reference texRef.
 CUfilter_mode_enum is defined as such:
 <pre>
 typedef enum CUfilter_mode_enum {
     CU_TR_FILTER_MODE_POINT = 0,
     CU_TR_FILTER_MODE_LINEAR = 1
 } CUfilter_mode;
 </pre>
 Note that this call has no effect if texRef is bound to linear memory.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefSetFlags</H3>
<PRE>
public static int <B>cuTexRefSetFlags</B>(<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                   int&nbsp;Flags)</PRE>
<DL>
<DD>Sets flags for a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefSetFlags(CUtexref texRef, unsigned int Flags);
 <br />
 <br />
 DESCRIPTION<br />
 Specifies optional flags to control the behavior of data returned through the texture reference. The valid
 flags are:
 - CU_TRSF_READ_AS_INTEGER, which suppresses the default behavior of having the texture
 promote integer data to floating point data in the range [0, 1];
 - CU_TRSF_NORMALIZED_COORDINATES, which suppresses the default behavior of hav-
 ing the texture coordinates range from [0, Dim) where Dim is the width or height of the CUDA array.
 Instead, the texture coordinates [0, 1.0) reference the entire breadth of the array dimension
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetAddress</H3>
<PRE>
public static int <B>cuTexRefGetAddress</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pdptr,
                                     <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the address associated with a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetAddress(CUdeviceptr* devPtr, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *devPtr the base address bound to the texture reference texRef, or returns CUDA_ERROR_INVALID_VALUE
 if the texture reference is not bound to any device memory range.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetArray</H3>
<PRE>
public static int <B>cuTexRefGetArray</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;phArray,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the array bound to a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetArray(CUarray* array, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *array the CUDA array bound by the texture reference texRef, or returns CUDA_ERROR_INVALID_VALUE
 if the texture reference is not bound to any CUDA array.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><!-- --></A><H3>
cuTexRefGetAddressMode</H3>
<PRE>
public static int <B>cuTexRefGetAddressMode</B>(int[]&nbsp;pam,
                                         <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef,
                                         int&nbsp;dim)</PRE>
<DL>
<DD>Gets the addressing mode used by a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetAddressMode(CUaddress_mode* mode, CUtexref texRef, int dim);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *mode the addressing mode corresponding to the dimension dim of the texture reference texRef.
 Currently the only valid values for dim are 0 and 1.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFilterMode</H3>
<PRE>
public static int <B>cuTexRefGetFilterMode</B>(int[]&nbsp;pfm,
                                        <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the filter-mode used by a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetFilterMode(CUfilter_mode* mode, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *mode the filtering mode of the texture reference texRef.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFormat</H3>
<PRE>
public static int <B>cuTexRefGetFormat</B>(int[]&nbsp;pFormat,
                                    int[]&nbsp;pNumChannels,
                                    <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the format used by a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetFormat(CUarray_format* format, int* numPackedComponents, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *format and *numPackedComponents the format and number of components of the CUDA
 array bound to the texture reference texRef. If format or numPackedComponents is null, it will be
 ignored.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFlags(int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuTexRefGetFlags(int[], jcuda.driver.CUtexref)"><!-- --></A><H3>
cuTexRefGetFlags</H3>
<PRE>
public static int <B>cuTexRefGetFlags</B>(int[]&nbsp;pFlags,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Gets the flags used by a texture-reference.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuTexRefGetFlags(unsigned int* flags, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *flags the flags of the texture reference texRef.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefCreate(jcuda.driver.CUtexref)"><CODE>cuTexRefCreate(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefDestroy(jcuda.driver.CUtexref)"><CODE>cuTexRefDestroy(jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)"><CODE>cuTexRefSetArray(jcuda.driver.CUtexref, jcuda.driver.CUarray, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)"><CODE>cuTexRefSetAddress(int[], jcuda.driver.CUtexref, jcuda.driver.CUdeviceptr, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetFormat(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)"><CODE>cuTexRefSetAddressMode(jcuda.driver.CUtexref, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFilterMode(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefSetFlags(jcuda.driver.CUtexref, int)"><CODE>cuTexRefSetFlags(jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)"><CODE>cuTexRefGetAddress(jcuda.driver.CUdeviceptr, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)"><CODE>cuTexRefGetArray(jcuda.driver.CUarray, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)"><CODE>cuTexRefGetAddressMode(int[], jcuda.driver.CUtexref, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFilterMode(int[], jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)"><CODE>cuTexRefGetFormat(int[], int[], jcuda.driver.CUtexref)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetSize(jcuda.driver.CUfunction, int)"><!-- --></A><H3>
cuParamSetSize</H3>
<PRE>
public static int <B>cuParamSetSize</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                 int&nbsp;numbytes)</PRE>
<DL>
<DD>Sets the parameter-size for the function.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuParamSetSize(CUfunction func, unsigned int numbytes);
 <br />
 <br />
 DESCRIPTION<br />
 Sets through numbytes the total size in bytes needed by the function parameters of function func.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSeti(jcuda.driver.CUfunction, int, int)"><!-- --></A><H3>
cuParamSeti</H3>
<PRE>
public static int <B>cuParamSeti</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              int&nbsp;value)</PRE>
<DL>
<DD>Adds an integer parameter to the function’s argument list.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuParamSeti(CUfunction func, int offset, unsigned int value);
 <br />
 <br />
 DESCRIPTION<br />
 Sets an integer parameter that will be specified the next time the kernel corresponding to func will be
 invoked. offset is a byte offset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetf(jcuda.driver.CUfunction, int, float)"><!-- --></A><H3>
cuParamSetf</H3>
<PRE>
public static int <B>cuParamSetf</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              float&nbsp;value)</PRE>
<DL>
<DD>Adds a floating-point parameter to the function’s argument list.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuParamSetf(CUfunction func, int offset, float value);
 <br />
 <br />
 DESCRIPTION<br />
 Sets a floating point parameter that will be specified the next time the kernel corresponding to func will be
 invoked. offset is a byte offset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><!-- --></A><H3>
cuParamSetv</H3>
<PRE>
public static int <B>cuParamSetv</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                              int&nbsp;offset,
                              <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                              int&nbsp;numbytes)</PRE>
<DL>
<DD>Adds arbitrary data to the function’s argument list.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuParamSetv(CUfunction func, int offset, void* ptr, unsigned int numbytes);
 <br />
 <br />
 DESCRIPTION<br />
 Copies an arbitrary amount of data into the parameter space of the kernel corresponding to func. offset is
 a byte offset.
 <br />
 <br />
 If the given Pointer is a device pointer, then the parameter is assumed
 to be the actual pointer (and not what the pointer points to), and the 
 size (numbytes) should be Sizeof.POINTER.<br />
 <br />
 Thus, to pass a pointer to device memory to a kernel, you may use
 <pre> 
 CUdeviceptr d_in = new CUdeviceptr();
 JCudaDriver.cuMemAlloc(d_in, n);
 JCudaDriver.cuParamSetv(hfunc, offset, d_in, Sizeof.POINTER);
 </pre>
 <br />
 If the given Pointer is a pointer to host memory, then it is assumed 
 that the parameter should be the value that the pointer points to,
 and thus, the size (numbytes) should be the Sizeof of the value that
 the pointer points to. Thus, to pass a short value to a kernel,
 you may use
 <pre>
 short value = 0;
 JCudaDriver.cuParamSetv(hfunc, offset, Pointer.to(new short[]{value}), Sizeof.SHORT);
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><!-- --></A><H3>
cuParamSetTexRef</H3>
<PRE>
public static int <B>cuParamSetTexRef</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;hfunc,
                                   int&nbsp;texunit,
                                   <A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver">CUtexref</A>&nbsp;hTexRef)</PRE>
<DL>
<DD>Adds a texture-reference to the function’s argument list.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuParamSetTexRef(CUfunction func, int texunit, CUtexref texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Makes the CUDA array or linear memory bound to the texture reference texRef available to a device
 program as a texture. In this version of CUDA, the texture reference must be obtained via cuModuleGetTexRef() 
 and the texunit parameter must be set to CU_PARAM_TR_DEFAULT.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunch(jcuda.driver.CUfunction)"><!-- --></A><H3>
cuLaunch</H3>
<PRE>
public static int <B>cuLaunch</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f)</PRE>
<DL>
<DD>Launches a CUDA function.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuLaunch(CUfunction func);
 <br />
 <br />
 DESCRIPTION<br />
 Invokes the kernel func on a 1Ã?1 grid of blocks. The block contains the number of threads specified by a
 previous call to cuFuncSetBlockShape().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><!-- --></A><H3>
cuLaunchGrid</H3>
<PRE>
public static int <B>cuLaunchGrid</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                               int&nbsp;grid_width,
                               int&nbsp;grid_height)</PRE>
<DL>
<DD>Launches a CUDA function.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuLaunchGrid(CUfunction func, int grid_width, int grid_height);
 CUresult cuLaunchGridAsync(CUfunction func, int grid_width, int grid_height, CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Invokes the kernel on a grid_width x grid_height grid of blocks. Each block contains the number of
 threads specified by a previous call to cuFuncSetBlockShape().
 cuLaunchGridAsync() can optionally be associated to a stream by passing a non-zero stream argument.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)"><CODE>cuFuncSetBlockShape(jcuda.driver.CUfunction, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuFuncSetSharedSize(jcuda.driver.CUfunction, int)"><CODE>cuFuncSetSharedSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetSize(jcuda.driver.CUfunction, int)"><CODE>cuParamSetSize(jcuda.driver.CUfunction, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSeti(jcuda.driver.CUfunction, int, int)"><CODE>cuParamSeti(jcuda.driver.CUfunction, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetf(jcuda.driver.CUfunction, int, float)"><CODE>cuParamSetf(jcuda.driver.CUfunction, int, float)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)"><CODE>cuParamSetv(jcuda.driver.CUfunction, int, jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)"><CODE>cuParamSetTexRef(jcuda.driver.CUfunction, int, jcuda.driver.CUtexref)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunch(jcuda.driver.CUfunction)"><CODE>cuLaunch(jcuda.driver.CUfunction)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuLaunchGridAsync(jcuda.driver.CUfunction, int, int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuLaunchGridAsync</H3>
<PRE>
public static int <B>cuLaunchGridAsync</B>(<A HREF="../../jcuda/driver/CUfunction.html" title="class in jcuda.driver">CUfunction</A>&nbsp;f,
                                    int&nbsp;grid_width,
                                    int&nbsp;grid_height,
                                    <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuLaunchGrid(jcuda.driver.CUfunction, int, int)"><CODE>cuLaunchGrid(jcuda.driver.CUfunction, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventCreate(jcuda.driver.CUevent, int)"><!-- --></A><H3>
cuEventCreate</H3>
<PRE>
public static int <B>cuEventCreate</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;phEvent,
                                int&nbsp;Flags)</PRE>
<DL>
<DD>Creates an event.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventCreate(CUevent* event, unsigned int flags);
 <br />
 <br />
 DESCRIPTION<br />
 Creates an event with the flags specified via Flags. Valid flags include:<br />
 - CU_EVENT_DEFAULT: Default event creation flag<br />
 - CU_EVENT_BLOCKING_SYNC: Specifies that event should use blocking synchronization
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><!-- --></A><H3>
cuEventRecord</H3>
<PRE>
public static int <B>cuEventRecord</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent,
                                <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Records an event.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventRecord(CUevent event, CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Records an event. If stream is non-zero, the event is recorded after all preceding operations in the stream
 have been completed; otherwise, it is recorded after all preceding operations in the CUDA context have been
 completed. Since this operation is asynchronous, cuEventQuery() and/or cuEventSynchronize() must
 be used to determine when the event has actually been recorded.
 If cuEventRecord() has previously been called and the event has not been recorded yet, this function
 returns CUDA_ERROR_INVALID_VALUE.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventQuery(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventQuery</H3>
<PRE>
public static int <B>cuEventQuery</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Queries an event’s status.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventQuery(CUevent event);
 <br />
 <br />
 DESCRIPTION<br />
 Returns CUDA_SUCCESS if the event has actually been recorded, or CUDA_ERROR_NOT_READY
 if not. If cuEventRecord() has not been called on this event, the function returns CUDA_ERROR_INVALID_VALUE
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_NOT_READY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventSynchronize(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventSynchronize</H3>
<PRE>
public static int <B>cuEventSynchronize</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Waits for an event to complete.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventSynchronize(CUevent event);
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the event has actually been recorded. If cuEventRecord() has not been called on this event,
 the function returns CUDA_ERROR_INVALID_VALUE.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventDestroy(jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventDestroy</H3>
<PRE>
public static int <B>cuEventDestroy</B>(<A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEvent)</PRE>
<DL>
<DD>Destroys an event.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventDestroy(CUevent event);
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the event.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><CODE>cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuEventElapsedTime(float[], jcuda.driver.CUevent, jcuda.driver.CUevent)"><!-- --></A><H3>
cuEventElapsedTime</H3>
<PRE>
public static int <B>cuEventElapsedTime</B>(float[]&nbsp;pMilliseconds,
                                     <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hStart,
                                     <A HREF="../../jcuda/driver/CUevent.html" title="class in jcuda.driver">CUevent</A>&nbsp;hEnd)</PRE>
<DL>
<DD>Computes the elapsed time between two events.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuEventDestroy(float* time, CUevent start, CUevent end);
 <br />
 <br />
 DESCRIPTION<br />
 Computes the elapsed time between two events (in milliseconds with a resolution of around 0.5 microseconds).
 If either event has not been recorded yet, this function returns CUDA_ERROR_INVALID_VALUE.
 If either event has been recorded with a non-zero stream, the result is undefined.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuEventCreate(jcuda.driver.CUevent, int)"><CODE>cuEventCreate(jcuda.driver.CUevent, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)"><CODE>cuEventRecord(jcuda.driver.CUevent, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventQuery(jcuda.driver.CUevent)"><CODE>cuEventQuery(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventSynchronize(jcuda.driver.CUevent)"><CODE>cuEventSynchronize(jcuda.driver.CUevent)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuEventDestroy(jcuda.driver.CUevent)"><CODE>cuEventDestroy(jcuda.driver.CUevent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamCreate(jcuda.driver.CUstream, int)"><!-- --></A><H3>
cuStreamCreate</H3>
<PRE>
public static int <B>cuStreamCreate</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;phStream,
                                 int&nbsp;Flags)</PRE>
<DL>
<DD>Create a stream.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuStreamCreate(CUstream* stream, unsigned int flags);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a stream. At present, flags is required to be 0.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamQuery(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamQuery</H3>
<PRE>
public static int <B>cuStreamQuery</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Determine status of a compute stream.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuStreamQuery(CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Returns CUDA_SUCCESS if all operations in the stream have completed, or CUDA_ERROR_NOT_READY
 if not.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_NOT_READY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamSynchronize(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamSynchronize</H3>
<PRE>
public static int <B>cuStreamSynchronize</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Block until a stream’s tasks are completed.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuStreamSynchronize(CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the device has completed all operations in the stream.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamDestroy(jcuda.driver.CUstream)"><CODE>cuStreamDestroy(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuStreamDestroy(jcuda.driver.CUstream)"><!-- --></A><H3>
cuStreamDestroy</H3>
<PRE>
public static int <B>cuStreamDestroy</B>(<A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Destroys a stream.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuStreamDestroy(CUstream stream);
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the stream.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamCreate(jcuda.driver.CUstream, int)"><CODE>cuStreamCreate(jcuda.driver.CUstream, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamQuery(jcuda.driver.CUstream)"><CODE>cuStreamQuery(jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuStreamSynchronize(jcuda.driver.CUstream)"><CODE>cuStreamSynchronize(jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLInit()"><!-- --></A><H3>
cuGLInit</H3>
<PRE>
public static int <B>cuGLInit</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Initializes GL interoperability.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLInit(void);
 <br />
 <br />
 DESCRIPTION<br />
 Initializes OpenGL interoperability. It must be called before performing any other OpenGL interoperability
 operations. It may fail if the needed OpenGL driver facilities are not available.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_UNKNOWN,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><!-- --></A><H3>
cuGLCtxCreate</H3>
<PRE>
public static int <B>cuGLCtxCreate</B>(<A HREF="../../jcuda/driver/CUcontext.html" title="class in jcuda.driver">CUcontext</A>&nbsp;pCtx,
                                int&nbsp;Flags,
                                <A HREF="../../jcuda/driver/CUdevice.html" title="class in jcuda.driver">CUdevice</A>&nbsp;device)</PRE>
<DL>
<DD>Create a CUDA context for interoperability with OpenGL.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLCtxCreate(CUcontext *pCtx, unsigned int Flags, CUdevice device);
 <br />
 <br />
 DESCRIPTION<br />
 Creates a new CUDA context, initializes OpenGL interoperability, and associates the CUDA context with
 the calling thread. It must be called before performing any other OpenGL interoperability operations. It
 may fail if the needed OpenGL driver facilities are not available. For usage of the Flags parameter, see
 cuCtxCreate.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_OUT_OF_MEMORY,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)"><!-- --></A><H3>
cuGraphicsGLRegisterBuffer</H3>
<PRE>
public static int <B>cuGraphicsGLRegisterBuffer</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                                             int&nbsp;buffer,
                                             int&nbsp;Flags)</PRE>
<DL>
<DD>Registers the buffer object specified by buffer for access by CUDA. 
 A handle to the registered object is returned as pCudaResource. 
 The map flags Flags specify the intended usage, as follows:<br />
 <br />
 <ul>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints 
       about how this resource will be used. It is therefore 
       assumed that this resource will be read from and written 
       to by CUDA. This is the default value.
   </li>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that 
       CUDA will not write to this resource.
   </li>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies 
       that CUDA will not read from this resource and will write 
       over the entire contents of the resource, so none of the 
       data previously stored in the resource will be preserved.
   </li>
 </ul>
 
 Parameters:<br />
 pCudaResource   - Pointer to the returned object handle<br />
 buffer  - name of buffer object to be registered<br />
 Flags   - Map flags<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_ALREADY_MAPPED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)"><!-- --></A><H3>
cuGraphicsGLRegisterImage</H3>
<PRE>
public static int <B>cuGraphicsGLRegisterImage</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;pCudaResource,
                                            int&nbsp;image,
                                            int&nbsp;target,
                                            int&nbsp;Flags)</PRE>
<DL>
<DD>Registers the texture or renderbuffer object specified by image for access by CUDA. 
 target must match the type of the object. A handle to the registered object is 
 returned as pCudaResource. The map flags Flags specify the intended usage, as follows:
 <ul>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints 
       about how this resource will be used. It is therefore 
       assumed that this resource will be read from and written 
       to by CUDA. This is the default value.
   </li>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that 
       CUDA will not write to this resource.
   </li>
   <li>CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies 
       that CUDA will not read from this resource and will write 
       over the entire contents of the resource, so none of the 
       data previously stored in the resource will be preserved.
   </li>
 </ul>
 Parameters:<br />
 pCudaResource   - Pointer to the returned object handle<br />
 image   - name of texture or renderbuffer object to be registered<br />
 target  - Identifies the type of object specified by image, and must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, or GL_RENDERBUFFER.<br />
 Flags   - Map flags<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_ALREADY_MAPPED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLRegisterBufferObject(int)"><!-- --></A><H3>
cuGLRegisterBufferObject</H3>
<PRE>
public static int <B>cuGLRegisterBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Registers a GL buffer object.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLRegisterBufferObject(GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Registers the buffer object of ID bufferObj for access by CUDA. This function must be called before CUDA
 can map the buffer object. While it is registered, the buffer object cannot be used by any OpenGL commands
 except as a data source for OpenGL drawing commands.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_ALREADY_MAPPED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><!-- --></A><H3>
cuGLMapBufferObject</H3>
<PRE>
public static int <B>cuGLMapBufferObject</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                      int[]&nbsp;size,
                                      int&nbsp;bufferobj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Maps a GL buffer object.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLMapBufferObject(CUdeviceptr* devPtr, unsigned int* size, GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Maps the buffer object of ID bufferObj into the address space of the current CUDA context and returns
 in *devPtr and *size the base pointer and size of the resulting mapping.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_MAP_FAILED,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnmapBufferObject(int)"><!-- --></A><H3>
cuGLUnmapBufferObject</H3>
<PRE>
public static int <B>cuGLUnmapBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Unmaps a GL buffer object.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLUnmapBufferObject(GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Unmaps the buffer object of ID bufferObj for access by CUDA.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnregisterBufferObject(int)"><!-- --></A><H3>
cuGLUnregisterBufferObject</H3>
<PRE>
public static int <B>cuGLUnregisterBufferObject</B>(int&nbsp;bufferobj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Unregister a GL buffer object.
 <br />
 <br />
 SYNOPSIS<br />
 CUresult cuGLUnregisterBufferObject(GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Unregisters the buffer object of ID bufferObj for access by CUDA.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLSetBufferObjectMapFlags(int, int)"><!-- --></A><H3>
cuGLSetBufferObjectMapFlags</H3>
<PRE>
public static int <B>cuGLSetBufferObjectMapFlags</B>(int&nbsp;buffer,
                                              int&nbsp;Flags)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Sets the map flags for the registered buffer object of ID bufferobj. <br />
 <br />
 Changes to Flags will take effect the next time bufferobj is mapped. 
 The Flags argument may be any of the following:<br />
 <ul>
   <li>CU_GL_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this 
       resource will be used. It is therefore assumed that this resource 
       will be read from and written to by CUDA kernels. This is the default value.
   </li>
   <li>CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that CUDA kernels which 
       access this resource will not write to this resource.
   </li>
   <li>CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA kernels 
       which access this resource will not read from this resource and will 
       write over the entire contents of the resource, so none of the data 
       previously stored in the resource will be preserved.
   </li>
 </ul>
 If bufferobj has not been registered for use with CUDA, then CUDA_ERROR_INVALID_HANDLE 
 is returned. If bufferobj is presently mapped for access by CUDA, 
 then CUDA_ERROR_ALREADY_MAPPED is returned.<br />
 <br />
 Parameters:<br />
 bufferobj   - Buffer object to unmap<br />
 Flags   - Map flags<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_NOT_INITIALIZED, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_ALREADY_MAPPED, CUDA_ERROR_INVALID_CONTEXT,<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)"><CODE>cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><CODE>cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuGLMapBufferObjectAsync</H3>
<PRE>
public static int <B>cuGLMapBufferObjectAsync</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;dptr,
                                           int[]&nbsp;size,
                                           int&nbsp;buffer,
                                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Maps the buffer object of ID bufferobj into the address space of the current CUDA 
 context and returns in *dptr and *size the base pointer and size of the resulting 
 mapping.<br />
 Stream hStream in the current CUDA context is synchronized with the current GL context.<br />
 <br />
 Parameters:<br />
 dptr    - Returned mapped base pointer<br />
 size    - Returned size of mapping<br />
 bufferobj   - Buffer object to map<br />
 hStream     - Stream to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_MAP_FAILED<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObject(int)"><CODE>cuGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><CODE>cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)"><CODE>cuGLSetBufferObjectMapFlags(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGLUnmapBufferObjectAsync(int, jcuda.driver.CUstream)"><!-- --></A><H3>
cuGLUnmapBufferObjectAsync</H3>
<PRE>
public static int <B>cuGLUnmapBufferObjectAsync</B>(int&nbsp;buffer,
                                             <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Unmaps the buffer object of ID bufferobj for access by CUDA.<br />
 <br />
 Stream hStream in the current CUDA context is synchronized with 
 the current GL context.<br />
 <br />
 Parameters:<br />
 bufferobj   - Buffer object to unmap<br />
 hStream     - Stream to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE<DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)"><CODE>cuGLCtxCreate(jcuda.driver.CUcontext, int, jcuda.driver.CUdevice)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLInit()"><CODE>cuGLInit()</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)"><CODE>cuGLMapBufferObject(jcuda.driver.CUdeviceptr, int[], int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLRegisterBufferObject(int)"><CODE>cuGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLUnregisterBufferObject(int)"><CODE>cuGLUnregisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)"><CODE>cuGLMapBufferObjectAsync(jcuda.driver.CUdeviceptr, int[], int, jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGLSetBufferObjectMapFlags(int, int)"><CODE>cuGLSetBufferObjectMapFlags(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsUnregisterResource(jcuda.driver.CUgraphicsResource)"><!-- --></A><H3>
cuGraphicsUnregisterResource</H3>
<PRE>
public static int <B>cuGraphicsUnregisterResource</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Unregisters the graphics resource resource so it is not accessible by CUDA unless registered again.
 <br />
 If resource is invalid then CUDA_ERROR_INVALID_HANDLE is returned.<br />
 <br />
 Parameters:<br />
 resource    - Resource to unregister<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_UNKNOWN
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsGLRegisterBuffer(jcuda.driver.CUgraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)"><CODE>cuGraphicsGLRegisterImage(jcuda.driver.CUgraphicsResource, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><!-- --></A><H3>
cuGraphicsSubResourceGetMappedArray</H3>
<PRE>
public static int <B>cuGraphicsSubResourceGetMappedArray</B>(<A HREF="../../jcuda/driver/CUarray.html" title="class in jcuda.driver">CUarray</A>&nbsp;pArray,
                                                      <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                                      int&nbsp;arrayIndex,
                                                      int&nbsp;mipLevel)</PRE>
<DL>
<DD>Returns in *pArray an array through which the subresource of the mapped 
 graphics resource resource which corresponds to array index arrayIndex 
 and mipmap level mipLevel may be accessed. The value set in *pArray may 
 change every time that resource is mapped.<br />
 <br />
 If resource is not a texture then it cannot be accessed via an array 
 and CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned. If arrayIndex is not 
 a valid array index for resource then CUDA_ERROR_INVALID_VALUE is 
 returned. If mipLevel is not a valid mipmap level for resource then 
 CUDA_ERROR_INVALID_VALUE is returned. If resource is not mapped then 
 CUDA_ERROR_NOT_MAPPED is returned.<br />
 <br />
 Parameters:<br />
 pArray  - Returned array through which a subresource of resource may be accessed<br />
 resource    - Mapped resource to access<br />
 arrayIndex  - Array index for array textures or cubemap face index as defined by 
               CUarray_cubemap_face for cubemap textures for the subresource to access<br />
 mipLevel    - Mipmap level for the subresource to access<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_NOT_MAPPED CUDA_ERROR_NOT_MAPPED_AS_ARRAY
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)"><!-- --></A><H3>
cuGraphicsResourceGetMappedPointer</H3>
<PRE>
public static int <B>cuGraphicsResourceGetMappedPointer</B>(<A HREF="../../jcuda/driver/CUdeviceptr.html" title="class in jcuda.driver">CUdeviceptr</A>&nbsp;pDevPtr,
                                                     int[]&nbsp;pSize,
                                                     <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Returns in *pDevPtr a pointer through which the mapped graphics resource resource 
 may be accessed. Returns in pSize the size of the memory in bytes which may be 
 accessed from that pointer. The value set in pPointer may change every time that 
 resource is mapped.<br />
 <br />
 If resource is not a buffer then it cannot be accessed via a pointer and 
 CUDA_ERROR_NOT_MAPPED_AS_POINTER is returned. If resource is not mapped 
 then CUDA_ERROR_NOT_MAPPED is returned.
 <br />
 Parameters:<br />
 pDevPtr     - Returned pointer through which resource may be accessed<br />
 pSize   - Returned size of the buffer accessible starting at *pPointer<br />
 resource    - Mapped resource to access<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_NOT_MAPPED CUDA_ERROR_NOT_MAPPED_AS_POINTER
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsResourceSetMapFlags(jcuda.driver.CUgraphicsResource, int)"><!-- --></A><H3>
cuGraphicsResourceSetMapFlags</H3>
<PRE>
public static int <B>cuGraphicsResourceSetMapFlags</B>(<A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>&nbsp;resource,
                                                int&nbsp;flags)</PRE>
<DL>
<DD>Set flags for mapping the graphics resource resource.<br />
 <br />
 Changes to flags will take effect the next time resource is mapped. 
 The flags argument may be any of the following:
 <ul>
   <li> 
        CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about 
        how this resource will be used. It is therefore assumed that 
        this resource will be read from and written to by CUDA kernels. 
        This is the default value.
   </li>
   <li> 
        CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY: Specifies that CUDA 
        kernels which access this resource will not write to this resource.
   </li>
   <li> 
        CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA 
        kernels which access this resource will not read from this resource 
        and will write over the entire contents of the resource, so none 
        of the data previously stored in the resource will be preserved.
   </li>
 </ul>
 If resource is presently mapped for access by CUDA then CUDA_ERROR_ALREADY_MAPPED 
 is returned. If flags is not one of the above values then CUDA_ERROR_INVALID_VALUE 
 is returned.<br />
 <br />
 Parameters:<br />
 resource    - Registered resource to set flags for<br />
 flags   - Parameters for resource mapping<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_VALUE, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_ALREADY_MAPPED
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><!-- --></A><H3>
cuGraphicsMapResources</H3>
<PRE>
public static int <B>cuGraphicsMapResources</B>(int&nbsp;count,
                                         <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                                         <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Maps the count graphics resources in resources for access by CUDA.<br />
 <br />
 The resources in resources may be accessed by CUDA until they are unmapped. 
 The graphics API from which resources were registered should not access any 
 resources while they are mapped by CUDA. If an application does so, the
 results are undefined.<br />
 <br />
 This function provides the synchronization guarantee that any graphics calls 
 issued before cuGraphicsMapResources() will complete before any subsequent 
 CUDA work issued in stream begins.<br />
 <br />
 If resources includes any duplicate entries then CUDA_ERROR_INVALID_HANDLE 
 is returned. If any of resources are presently mapped for access by CUDA 
 then CUDA_ERROR_ALREADY_MAPPED is returned.
 <br />
 Parameters:<br />
 count   - Number of resources to map<br />
 resources   - Resources to map for CUDA usage<br />
 hStream     - Stream with which to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, CUDA_ERROR_ALREADY_MAPPED, 
 CUDA_ERROR_UNKNOWN
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)"><CODE>cuGraphicsResourceGetMappedPointer(jcuda.driver.CUdeviceptr, int[], jcuda.driver.CUgraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)"><CODE>cuGraphicsSubResourceGetMappedArray(jcuda.driver.CUarray, jcuda.driver.CUgraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cuGraphicsUnmapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><!-- --></A><H3>
cuGraphicsUnmapResources</H3>
<PRE>
public static int <B>cuGraphicsUnmapResources</B>(int&nbsp;count,
                                           <A HREF="../../jcuda/driver/CUgraphicsResource.html" title="class in jcuda.driver">CUgraphicsResource</A>[]&nbsp;resources,
                                           <A HREF="../../jcuda/driver/CUstream.html" title="class in jcuda.driver">CUstream</A>&nbsp;hStream)</PRE>
<DL>
<DD>Unmaps the count graphics resources in resources.<br />
 <br />
 Once unmapped, the resources in resources may not be accessed by 
 CUDA until they are mapped again.<br />
 <br />
 This function provides the synchronization guarantee that any CUDA 
 work issued in stream before cuGraphicsUnmapResources() will complete 
 before any subsequently issued graphics work begins.<br />
 <br />
 If resources includes any duplicate entries then CUDA_ERROR_INVALID_HANDLE 
 is returned. If any of resources are not presently mapped for access by 
 CUDA then CUDA_ERROR_NOT_MAPPED is returned.<br />
 <br />
 Parameters:<br />
 count   - Number of resources to unmap<br />
 resources   - Resources to unmap<br />
 hStream     - Stream with which to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>CUDA_SUCCESS, CUDA_ERROR_DEINITIALIZED, CUDA_ERROR_NOT_INITIALIZED, 
 CUDA_ERROR_INVALID_CONTEXT, CUDA_ERROR_INVALID_HANDLE, 
 CUDA_ERROR_NOT_MAPPED, CUDA_ERROR_UNKNOWN 
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/driver/JCudaDriver.html#cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)"><CODE>cuGraphicsMapResources(int, jcuda.driver.CUgraphicsResource[], jcuda.driver.CUstream)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCudaDriver.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/driver/CUtexref.html" title="class in jcuda.driver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/driver/JCudaDriver.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCudaDriver.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
