<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_04) on Thu Mar 25 20:46:30 CET 2010 -->
<TITLE>
JCuda (JCuda API Documentation)
</TITLE>

<META NAME="date" CONTENT="2010-03-25">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JCuda (JCuda API Documentation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCuda.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/runtime/JCuda.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCuda.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jcuda.runtime</FONT>
<BR>
Class JCuda</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>jcuda.runtime.JCuda</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>JCuda</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Java bindings for the NVidia CUDA runtime API.<br />
 <br />
 Most comments are taken from the CUDA reference manual<br />
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceBlockingSync">cudaDeviceBlockingSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Use blocking synchronization</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceLmemResizeToMax">cudaDeviceLmemResizeToMax</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Keep local memory allocation after launch</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceMapHost">cudaDeviceMapHost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Support mapped pinned allocations</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceMask">cudaDeviceMask</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flags mask</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleAuto">cudaDeviceScheduleAuto</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Automatic scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleSpin">cudaDeviceScheduleSpin</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Spin default scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDeviceScheduleYield">cudaDeviceScheduleYield</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device flag - Yield default scheduling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventBlockingSync">cudaEventBlockingSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event uses blocking synchronization</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventDefault">cudaEventDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default event flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocDefault">cudaHostAllocDefault</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default page-locked allocation flag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocMapped">cudaHostAllocMapped</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map allocation into device space</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocPortable">cudaHostAllocPortable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pinned memory accessible by all CUDA contexts</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAllocWriteCombined">cudaHostAllocWriteCombined</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write-combined memory</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)">cudaBindTexture</A></B>(long[]&nbsp;offset,
                <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds size bytes of the memory area pointed to by devPtr to texture reference texRef.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)">cudaBindTexture2D</A></B>(long[]&nbsp;offset,
                  <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                  long&nbsp;width,
                  long&nbsp;height,
                  long&nbsp;pitch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the 2D memory area pointed to by devPtr to the texture reference texref.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)">cudaBindTextureToArray</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                       <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                       <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the CUDA array array to texture reference texRef.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)">cudaChooseDevice</A></B>(int[]&nbsp;device,
                 <A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select compute-device which best matches criteria.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)">cudaConfigureCall</A></B>(<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;gridDim,
                  <A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;blockDim,
                  long&nbsp;sharedMem,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configure a device-launch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)">cudaCreateChannelDesc</A></B>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;z,
                      int&nbsp;w,
                      int&nbsp;cudaChannelFormatKind_f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a channel descriptor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaDriverGetVersion(int[])">cudaDriverGetVersion</A></B>(int[]&nbsp;driverVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in driverVersion the version number of the installed CUDA driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)">cudaEventCreate</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an event-object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)">cudaEventCreateWithFlags</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an event object with the specified flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)">cudaEventDestroy</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys an event-object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)">cudaEventElapsedTime</A></B>(float[]&nbsp;ms,
                     <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;start,
                     <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the elapsed time between events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)">cudaEventQuery</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query if an event has been recorded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)">cudaEventRecord</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Records an event.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)">cudaEventSynchronize</A></B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for an event to be recorded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)">cudaFree</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees memory on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)">cudaFreeArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees an array on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)">cudaFreeHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees page-locked memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)">cudaFuncGetAttributes</A></B>(<A HREF="../../jcuda/runtime/cudaFuncAttributes.html" title="class in jcuda.runtime">cudaFuncAttributes</A>&nbsp;attr,
                      java.lang.String&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function obtains the attributes of a function specified via func.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)">cudaGetChannelDesc</A></B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                   <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Low-level texture API.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])">cudaGetDevice</A></B>(int[]&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns which device is currently being used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])">cudaGetDeviceCount</A></B>(int[]&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of compute-capable devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)">cudaGetDeviceProperties</A></B>(<A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop,
                        int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information on the compute-device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetErrorString(int)">cudaGetErrorString</A></B>(int&nbsp;error)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the message string from an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetLastError()">cudaGetLastError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last error from a run-time call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)">cudaGetSymbolAddress</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                     java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the address associated with a CUDA symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolSize(long[], java.lang.String)">cudaGetSymbolSize</A></B>(long[]&nbsp;size,
                  java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the size of the object associated with a CUDA symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)">cudaGetTextureAlignmentOffset</A></B>(long[]&nbsp;offset,
                              <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *offset the offset that was returned when texture reference texRef was bound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)">cudaGetTextureReference</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                        java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *texRef the structure associated to the texture reference defined by symbol symbol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)">cudaGLMapBufferObject</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                      int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObjectAsync(jcuda.Pointer, int, jcuda.runtime.cudaStream_t)">cudaGLMapBufferObjectAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                           int&nbsp;bufObj,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)">cudaGLRegisterBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetBufferObjectMapFlags(int, int)">cudaGLSetBufferObjectMapFlags</A></B>(int&nbsp;bufObj,
                              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)">cudaGLSetGLDevice</A></B>(int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the CUDA device for use with GL Interopability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)">cudaGLUnmapBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObjectAsync(int, jcuda.runtime.cudaStream_t)">cudaGLUnmapBufferObjectAsync</A></B>(int&nbsp;bufObj,
                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)">cudaGLUnregisterBufferObject</A></B>(int&nbsp;bufObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)">cudaGraphicsGLRegisterBuffer</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                             int&nbsp;buffer,
                             int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers the buffer object specified by buffer for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)">cudaGraphicsGLRegisterImage</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                            int&nbsp;image,
                            int&nbsp;target,
                            int&nbsp;Flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Registers the texture or renderbuffer object specified by image for 
 access by CUDA. target must match the type of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)">cudaGraphicsMapResources</A></B>(int&nbsp;count,
                         <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps the count graphics resources in resources for access by CUDA.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)">cudaGraphicsResourceGetMappedPointer</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                     long[]&nbsp;size,
                                     <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *devPtr a pointer through which the mapped graphics resource resource 
 may be accessed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)">cudaGraphicsResourceSetMapFlags</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set flags for mapping the graphics resource resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)">cudaGraphicsSubResourceGetMappedArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                      <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                      int&nbsp;arrayIndex,
                                      int&nbsp;mipLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in *array an array through which the subresource of the mapped 
 graphics resource resource which corresponds to array index arrayIndex 
 and mipmap level mipLevel may be accessed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)">cudaGraphicsUnmapResources</A></B>(int&nbsp;count,
                           <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmaps the count graphics resources in resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)">cudaGraphicsUnregisterResource</A></B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unregisters the graphics resource resource so it is not 
 accessible by CUDA unless registered again.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostAlloc(jcuda.Pointer, long, int)">cudaHostAlloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
              long&nbsp;size,
              int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates count bytes of host memory that is page-locked and accessible to the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)">cudaHostGetDevicePointer</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pDevice,
                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pHost,
                         int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passes back the device pointer corresponding to the mapped, pinned host buffer allocated by cudaHostAlloc().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)">cudaLaunch</A></B>(java.lang.String&nbsp;symbol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launches a device function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)">cudaMalloc</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
           long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate memory on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)">cudaMalloc3D</A></B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
             <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates logical 1D, 2D, or 3D memory objects on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)">cudaMalloc3DArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                  <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)">cudaMallocArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                long&nbsp;width,
                long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)">cudaMallocHost</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
               long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates page-locked memory on the host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)">cudaMallocPitch</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                long[]&nbsp;pitch,
                long&nbsp;width,
                long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates memory on the GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)">cudaMemcpy</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
           long&nbsp;count,
           int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between GPU and host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)">cudaMemcpy2D</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
             long&nbsp;dpitch,
             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
             long&nbsp;spitch,
             long&nbsp;width,
             long&nbsp;height,
             int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)">cudaMemcpy2DArrayToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                         long&nbsp;wOffsetDst,
                         long&nbsp;hOffsetDst,
                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                         long&nbsp;wOffsetSrc,
                         long&nbsp;hOffsetSrc,
                         long&nbsp;width,
                         long&nbsp;height,
                         int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                  long&nbsp;dpitch,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                  long&nbsp;spitch,
                  long&nbsp;width,
                  long&nbsp;height,
                  int&nbsp;cudaMemcpyKind_kind,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)">cudaMemcpy2DFromArray</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                      long&nbsp;dpitch,
                      <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                      long&nbsp;wOffset,
                      long&nbsp;hOffset,
                      long&nbsp;width,
                      long&nbsp;height,
                      int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DFromArrayAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                           long&nbsp;dpitch,
                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                           long&nbsp;wOffset,
                           long&nbsp;hOffset,
                           long&nbsp;width,
                           long&nbsp;height,
                           int&nbsp;cudaMemcpyKind_kind,
                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)">cudaMemcpy2DToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                    long&nbsp;wOffset,
                    long&nbsp;hOffset,
                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                    long&nbsp;spitch,
                    long&nbsp;width,
                    long&nbsp;height,
                    int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpy2DToArrayAsync</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                         long&nbsp;wOffset,
                         long&nbsp;hOffset,
                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                         long&nbsp;spitch,
                         long&nbsp;width,
                         long&nbsp;height,
                         int&nbsp;cudaMemcpyKind_kind,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)">cudaMemcpy3D</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between between 3D objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)">cudaMemcpy3DAsync</A></B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p,
                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)">cudaMemcpyArrayToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                       long&nbsp;wOffsetDst,
                       long&nbsp;hOffsetDst,
                       <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                       long&nbsp;wOffsetSrc,
                       long&nbsp;hOffsetSrc,
                       long&nbsp;count,
                       int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                long&nbsp;count,
                int&nbsp;cudaMemcpyKind_kind,
                <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)">cudaMemcpyFromArray</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                    <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                    long&nbsp;wOffset,
                    long&nbsp;hOffset,
                    long&nbsp;count,
                    int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyFromArrayAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                         long&nbsp;wOffset,
                         long&nbsp;hOffset,
                         long&nbsp;count,
                         int&nbsp;cudaMemcpyKind_kind,
                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)">cudaMemcpyFromSymbol</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                     java.lang.String&nbsp;symbol,
                     long&nbsp;count,
                     long&nbsp;offset,
                     int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from GPU to host memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyFromSymbolAsync</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                          java.lang.String&nbsp;symbol,
                          long&nbsp;count,
                          long&nbsp;offset,
                          int&nbsp;cudaMemcpyKind_kind,
                          <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)">cudaMemcpyToArray</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                  long&nbsp;wOffset,
                  long&nbsp;hOffset,
                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                  long&nbsp;count,
                  int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data between host and device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyToArrayAsync</A></B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                       long&nbsp;wOffset,
                       long&nbsp;hOffset,
                       <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                       long&nbsp;count,
                       int&nbsp;cudaMemcpyKind_kind,
                       <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)">cudaMemcpyToSymbol</A></B>(java.lang.String&nbsp;symbol,
                   <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                   long&nbsp;count,
                   long&nbsp;offset,
                   int&nbsp;cudaMemcpyKind_kind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from host memory to GPU.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)">cudaMemcpyToSymbolAsync</A></B>(java.lang.String&nbsp;symbol,
                        <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                        long&nbsp;count,
                        long&nbsp;offset,
                        int&nbsp;cudaMemcpyKind_kind,
                        <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)">cudaMemset</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
           int&nbsp;c,
           long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets GPU memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)">cudaMemset2D</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
             long&nbsp;pitch,
             int&nbsp;c,
             long&nbsp;width,
             long&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets GPU memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)">cudaMemset3D</A></B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
             int&nbsp;value,
             <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes or sets GPU memory to a value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaRuntimeGetVersion(int[])">cudaRuntimeGetVersion</A></B>(int[]&nbsp;runtimeVersion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in runtimeVersion the version number of the installed CUDA Runtime.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)">cudaSetDevice</A></B>(int&nbsp;device)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets device to be used for GPU executions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)">cudaSetDeviceFlags</A></B>(int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Records flags as the flags to use when the active host thread executes device code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)">cudaSetupArgument</A></B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;arg,
                  long&nbsp;size,
                  long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configure a device-launch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaSetValidDevices(int[], int)">cudaSetValidDevices</A></B>(int[]&nbsp;device_arr,
                    int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a list of devices for CUDA execution in priority order using device_arr.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)">cudaStreamCreate</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an async stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)">cudaStreamDestroy</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroys and cleans-up a stream object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)">cudaStreamQuery</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries a stream for completion-status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)">cudaStreamSynchronize</A></B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for stream tasks to complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadExit()">cudaThreadExit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit and clean-up from CUDA launches.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSynchronize()">cudaThreadSynchronize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for compute-device to finish.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)">cudaUnbindTexture</A></B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unbinds the texture bound to texture reference texRef.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#initialize()">initialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the native library.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#setEmulation(boolean)">setEmulation</A></B>(boolean&nbsp;emulation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>The emulation mode has been deprecated in
 CUDA 3.0. This function no longer has any effect, and
 will be removed in the next release.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#setExceptionsEnabled(boolean)">setExceptionsEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables exceptions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jcuda/runtime/JCuda.html#setLogLevel(jcuda.LogLevel)">setLogLevel</A></B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified log level for the JCuda runtime library.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="cudaHostAllocDefault"><!-- --></A><H3>
cudaHostAllocDefault</H3>
<PRE>
public static final int <B>cudaHostAllocDefault</B></PRE>
<DL>
<DD>Default page-locked allocation flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocPortable"><!-- --></A><H3>
cudaHostAllocPortable</H3>
<PRE>
public static final int <B>cudaHostAllocPortable</B></PRE>
<DL>
<DD>Pinned memory accessible by all CUDA contexts
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocPortable">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocMapped"><!-- --></A><H3>
cudaHostAllocMapped</H3>
<PRE>
public static final int <B>cudaHostAllocMapped</B></PRE>
<DL>
<DD>Map allocation into device space
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocMapped">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaHostAllocWriteCombined"><!-- --></A><H3>
cudaHostAllocWriteCombined</H3>
<PRE>
public static final int <B>cudaHostAllocWriteCombined</B></PRE>
<DL>
<DD>Write-combined memory
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaHostAllocWriteCombined">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventDefault"><!-- --></A><H3>
cudaEventDefault</H3>
<PRE>
public static final int <B>cudaEventDefault</B></PRE>
<DL>
<DD>Default event flag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventDefault">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaEventBlockingSync"><!-- --></A><H3>
cudaEventBlockingSync</H3>
<PRE>
public static final int <B>cudaEventBlockingSync</B></PRE>
<DL>
<DD>Event uses blocking synchronization
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaEventBlockingSync">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleAuto"><!-- --></A><H3>
cudaDeviceScheduleAuto</H3>
<PRE>
public static final int <B>cudaDeviceScheduleAuto</B></PRE>
<DL>
<DD>Device flag - Automatic scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleAuto">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleSpin"><!-- --></A><H3>
cudaDeviceScheduleSpin</H3>
<PRE>
public static final int <B>cudaDeviceScheduleSpin</B></PRE>
<DL>
<DD>Device flag - Spin default scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleSpin">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceScheduleYield"><!-- --></A><H3>
cudaDeviceScheduleYield</H3>
<PRE>
public static final int <B>cudaDeviceScheduleYield</B></PRE>
<DL>
<DD>Device flag - Yield default scheduling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceScheduleYield">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceBlockingSync"><!-- --></A><H3>
cudaDeviceBlockingSync</H3>
<PRE>
public static final int <B>cudaDeviceBlockingSync</B></PRE>
<DL>
<DD>Device flag - Use blocking synchronization
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceBlockingSync">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceMapHost"><!-- --></A><H3>
cudaDeviceMapHost</H3>
<PRE>
public static final int <B>cudaDeviceMapHost</B></PRE>
<DL>
<DD>Device flag - Support mapped pinned allocations
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceMapHost">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceLmemResizeToMax"><!-- --></A><H3>
cudaDeviceLmemResizeToMax</H3>
<PRE>
public static final int <B>cudaDeviceLmemResizeToMax</B></PRE>
<DL>
<DD>Device flag - Keep local memory allocation after launch
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceLmemResizeToMax">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="cudaDeviceMask"><!-- --></A><H3>
cudaDeviceMask</H3>
<PRE>
public static final int <B>cudaDeviceMask</B></PRE>
<DL>
<DD>Device flags mask
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jcuda.runtime.JCuda.cudaDeviceMask">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setEmulation(boolean)"><!-- --></A><H3>
setEmulation</H3>
<PRE>
public static void <B>setEmulation</B>(boolean&nbsp;emulation)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>The emulation mode has been deprecated in
 CUDA 3.0. This function no longer has any effect, and
 will be removed in the next release.</I>
<P>
<DD>Set the flag which indicates whether a call to any
 function should initialize the JCuda runtime API
 in emulation mode.<br />
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLogLevel(jcuda.LogLevel)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public static void <B>setLogLevel</B>(<A HREF="../../jcuda/LogLevel.html" title="enum in jcuda">LogLevel</A>&nbsp;logLevel)</PRE>
<DL>
<DD>Set the specified log level for the JCuda runtime library.<br />
 <br />
 Currently supported log levels:
 <br />
 LOG_QUIET: Never print anything <br />
 LOG_ERROR: Print error messages <br />
 LOG_TRACE: Print a trace of all native function calls <br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The log level to use.</DL>
</DD>
</DL>
<HR>

<A NAME="setExceptionsEnabled(boolean)"><!-- --></A><H3>
setExceptionsEnabled</H3>
<PRE>
public static void <B>setExceptionsEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Enables or disables exceptions. By default, the methods of this class
 only return the cudaError error code from the underlying CUDA function.
 If exceptions are enabled, a CudaException with a detailed error 
 message will be thrown if a method is about to return a result code 
 that is not cudaError.cudaSuccess
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - Whether exceptions are enabled</DL>
</DD>
</DL>
<HR>

<A NAME="initialize()"><!-- --></A><H3>
initialize</H3>
<PRE>
public static void <B>initialize</B>()</PRE>
<DL>
<DD>Initializes the native library. Note that this method
 does not have to be called explicitly by the user of
 the library: The library will automatically be 
 initialized with the first function call.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDeviceCount(int[])"><!-- --></A><H3>
cudaGetDeviceCount</H3>
<PRE>
public static int <B>cudaGetDeviceCount</B>(int[]&nbsp;count)</PRE>
<DL>
<DD>Returns the number of compute-capable devices.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetDeviceCount( int* count )
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *count the number of devices with compute capability greater or equal to 1.0 that are available
 for execution. If there is no such device, cudaGetDeviceCount() returns 1 and device 0 only supports device
 emulation mode. Since this device will be able to emulate all hardware features, this device will report major
 and minor compute capability versions of 9999.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetDevice(int)"><!-- --></A><H3>
cudaSetDevice</H3>
<PRE>
public static int <B>cudaSetDevice</B>(int&nbsp;device)</PRE>
<DL>
<DD>Sets device to be used for GPU executions.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaSetDevice( int dev )
 <br />
 <br />
 DESCRIPTION<br />
 Records dev as the device on which the active host thread executes the device code.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetDeviceFlags(int)"><!-- --></A><H3>
cudaSetDeviceFlags</H3>
<PRE>
public static int <B>cudaSetDeviceFlags</B>(int&nbsp;flags)</PRE>
<DL>
<DD>Records flags as the flags to use when the active host thread executes device code. If the host thread has already
 initialized the CUDA runtime by calling non-device management runtime functions, this call returns cudaErrorSetOn-
 ActiveProcess.<br />
 The two LSBs of the flags parameter can be used to control how the CPU thread interacts with the OS scheduler
 when waiting for results from the device.<br />
 - cudaDeviceScheduleAuto: The default value if the flags parameter is zero, uses a heuristic based on the
 number of active CUDA contexts in the process C and the number of logical processors in the system P. If C &gt;
 P, then CUDA will yield to other OS threads when waiting for the device, otherwise CUDA will not yield while
 waiting for results and actively spin on the processor.<br />
 - cudaDeviceScheduleSpin: Instruct CUDA to actively spin when waiting for results from the device. This can
 decrease latency when waiting for the device, but may lower the performance of CPU threads if they are performing
 work in parallel with the CUDA thread.<br />
 - cudaDeviceScheduleYield: Instruct CUDA to yield its thread when waiting for results from the device. This
 can increase latency when waiting for the device, but can increase the performance of CPU threads performing
 work in parallel with the device.<br />
 - cudaDeviceBlockingSync: Instruct CUDA to block the CPU thread on a synchronization primitive when waiting
 for the device to finish work.<br />
 - cudaDeviceMapHost: This flag must be set in order to allocate pinned host memory that is accessible to the
 device. If this flag is not set, cudaHostGetDevicePointer() will always return a failure code.<br />
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flags</CODE> - - Parameters for device operation
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorSetOnActiveProcess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetValidDevices(int[], int)"><CODE>cudaSetValidDevices(int[], int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetValidDevices(int[], int)"><!-- --></A><H3>
cudaSetValidDevices</H3>
<PRE>
public static int <B>cudaSetValidDevices</B>(int[]&nbsp;device_arr,
                                      int&nbsp;len)</PRE>
<DL>
<DD>Sets a list of devices for CUDA execution in priority order using device_arr. The parameter len specifies the
 number of elements in the list. CUDA will try devices from the list sequentially until it finds one that works. If this
 function is not called, or if it is called with a len of 0, then CUDA will go back to its default behavior of trying devices
 sequentially from a default list containing all of the available CUDA devices in the system. If a specified device ID in
 the list does not exist, this function will return cudaErrorInvalidDevice. If len is not 0 and device_arr is NULL
 or if len is greater than the number of devices in the system, then cudaErrorInvalidValue is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device_arr</CODE> - - List of devices to try<DD><CODE>len</CODE> - - Number of devices in specified list
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevice<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDevice(int[])"><!-- --></A><H3>
cudaGetDevice</H3>
<PRE>
public static int <B>cudaGetDevice</B>(int[]&nbsp;device)</PRE>
<DL>
<DD>Returns which device is currently being used.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetDevice( int* dev )
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *dev the device on which the active host thread executes the device code.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><!-- --></A><H3>
cudaGetDeviceProperties</H3>
<PRE>
public static int <B>cudaGetDeviceProperties</B>(<A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop,
                                          int&nbsp;device)</PRE>
<DL>
<DD>Returns information on the compute-device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetDeviceProperties( struct cudaDeviceProp* prop, int dev )
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *prop the properties of device dev. The cudaDeviceProp structure is defined as:
 <pre>
 struct cudaDeviceProp {
     char name[256];
     size_t totalGlobalMem;
     size_t sharedMemPerBlock;
     int regsPerBlock;
     int warpSize;
     size_t memPitch;
     int maxThreadsPerBlock;
     int maxThreadsDim[3];
     int maxGridSize[3];
     size_t totalConstMem;
     int major;
     int minor;
     int clockRate;
     size_t textureAlignment;
     int deviceOverlap;
     int multiProcessorCount;
 }
 </pre>
 where:
 name
 is an ASCII string identifying the device;
 totalGlobalMem
 is the total amount of global memory available on the device in bytes;
 sharedMemPerBlock
 is the maximum amount of shared memory available to a thread block in bytes; this amount is shared
 by all thread blocks simultaneously resident on a multiprocessor;
 regsPerBlock
 is the maximum number of 32-bit registers available to a thread block; this number is shared by all
 thread blocks simultaneously resident on a multiprocessor;
 warpSize
 is the warp size in threads;
 memPitch
 is the maximum pitch in bytes allowed by the memory copy functions that involve memory regions
 allocated through cudaMallocPitch();
 maxThreadsPerBlock
 is the maximum number of threads per block;
 maxThreadsDim[3]
 is the maximum sizes of each dimension of a block;
 maxGridSize[3]
 is the maximum sizes of each dimension of a grid;
 totalConstMem
 is the total amount of constant memory available on the device in bytes;
 major, minor
 are the major and minor revision numbers defining the devices compute capability;
 clockRate
 is the clock frequency in kilohertz;
 textureAlignment
 is the alignment requirement; texture base addresses that are aligned to textureAlignment bytes do
 not need an offset applied to texture fetches;
 deviceOverlap
 is 1 if the device can concurrently copy memory between host and device while executing a kernel, or
 0 if not;
 multiProcessorCount
 is the number of multiprocessors on the device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><CODE>cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaChooseDevice(int[], jcuda.runtime.cudaDeviceProp)"><!-- --></A><H3>
cudaChooseDevice</H3>
<PRE>
public static int <B>cudaChooseDevice</B>(int[]&nbsp;device,
                                   <A HREF="../../jcuda/runtime/cudaDeviceProp.html" title="class in jcuda.runtime">cudaDeviceProp</A>&nbsp;prop)</PRE>
<DL>
<DD>Select compute-device which best matches criteria.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaChooseDevice( int* dev, const struct cudaDeviceProp* prop )
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *dev the device which properties best match *prop.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceCount(int[])"><CODE>cudaGetDeviceCount(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDevice(int[])"><CODE>cudaGetDevice(int[])</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetDevice(int)"><CODE>cudaSetDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)"><CODE>cudaGetDeviceProperties(jcuda.runtime.cudaDeviceProp, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMalloc3D</H3>
<PRE>
public static int <B>cudaMalloc3D</B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
                               <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Allocates logical 1D, 2D, or 3D memory objects on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 <pre>
 struct cudaPitchedPtr {
     void *ptr;
     size_t pitch;
     size_t xsize;
     size_t ysize;
 };
 </pre>
 <pre>
 struct cudaExtent {
     size_t width;
     size_t height;
     size_t depth;
 };
 </pre>
 cudaError_t cudaMalloc3D( struct cudaPitchedPtr* pitchDevPtr, struct cudaExtent extent )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates at least width*height*depth bytes of linear memory on the device and returns a pitchedDevPtr
 in which ptr is a pointer to the allocated memory. The function may pad the allocation to ensure hardware
 alignment requirements are met. The pitch returned in the pitch field of the pitchedDevPtr is the width
 in bytes of the allocation.
 The returned cudaPitchedPtr contains additional fields xsize and ysize, the logical width and height of the
 allocation, which are equivalent to the width and height extent parameters provided by the programmer
 during allocation.
 For allocations of 2D, 3D objects, it is highly recommended that programmers perform allocations using
 cudaMalloc3D() or cudaMallocPitch(). Due to alignment restrictions in the hardware, this is especially
 true if the application will be performing memory copies involving 2D or 3D objects (whether linear memory
 or CUDA arrays).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><CODE>cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMalloc3DArray</H3>
<PRE>
public static int <B>cudaMalloc3DArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                    <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                    <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Allocate an array on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 struct cudaExtent { size_t width; size_t height; size_t depth; };
 </pre>
 cudaError_t cudaMalloc3DArray( struct cudaArray** arrayPtr, const struct cudaChannelFormatDesc*
 desc, struct cudaExtent extent )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates a CUDA array according to the cudaChannelFormatDesc structure desc and returns a handle
 to the new CUDA array in *arrayPtr. The cudaChannelFormatDesc is defined as:
 <pre>
 struct cudaChannelFormatDesc {
     int x, y, z, w;
     enum cudaChannelFormatKind f;
 };
 </pre>
 where cudaChannelFormatKind is one of cudaChannelFormatKindSigned, cudaChannelFormatKin-
 dUnsigned, cudaChannelFormatKindFloat.<br />
 <br />
 cudaMalloc3DArray is able to allocate 1D, 2D, or 3D arrays.<br />
 A 1D array is allocated if the height and depth extent are both zero. For 1D arrays valid extents are
 {(1, 8192), 0, 0}.<br />
 A 2D array is allocated if only the depth extent is zero. For 2D arrays valid extents are {(1, 65536),
 (1, 32768), 0}.<br />
 A 3D array is allocate if all three extents are non-zero. For 3D arrays valid extents are {(1, 2048), (1,
 2048), (1, 2048)}.<br />
 <br />
 Note: That because of the differing extent limits it may be advantageous to use a degenerate array (with
 unused dimensions set to one) of higher dimensionality. For instance, a degenerate 2D array allows for
 significantly more linear storage than a 1D array.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><!-- --></A><H3>
cudaMemset3D</H3>
<PRE>
public static int <B>cudaMemset3D</B>(<A HREF="../../jcuda/runtime/cudaPitchedPtr.html" title="class in jcuda.runtime">cudaPitchedPtr</A>&nbsp;pitchDevPtr,
                               int&nbsp;value,
                               <A HREF="../../jcuda/runtime/cudaExtent.html" title="class in jcuda.runtime">cudaExtent</A>&nbsp;extent)</PRE>
<DL>
<DD>Initializes or sets GPU memory to a value.
 <br />
 <br />
 SYNOPSIS<br />
 <pre>
 struct cudaPitchedPtr {
     void *ptr;
     size_t pitch;
     size_t xsize;
     size_t ysize;
 };
 </pre>
 <pre>
 struct cudaExtent {
     size_t width;
     size_t height;
     size_t depth;
 };
 </pre>
 cudaError_t cudaMemset3D( struct cudaPitchedPtr dstPitchPtr, int value, struct cudaExtent extent
 )
 <br />
 <br />
 DESCRIPTION<br />
 Initializes each element of a 3D array to the specified value value. The object to initialize is defined by
 dstPitchPtr. The pitch field of dstPitchPtr is the width in memory in bytes of the 3D array pointed to
 by dstPitchPtr, including any padding added to the end of each row. The xsize field specifies the logical
 width of each row in bytes, while the ysize field specifies the height of each 2D slice in rows.
 The extents of the initialized region are specified as a width in bytes, a height in rows, and a depth in slices.
 Extents with width greater than or equal to the xsize of dstPitchPtr may perform significantly faster than
 extents narrower than the xsize. Secondarily, extents with height equal to the ysize of dstPitchPtr will
 perform faster than when the hieght is shorter than the ysize.
 This function performs fastest when the dstPitchPtr has been allocated by cudaMalloc3D().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><!-- --></A><H3>
cudaMemcpy3D</H3>
<PRE>
public static int <B>cudaMemcpy3D</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p)</PRE>
<DL>
<DD>Copies data between between 3D objects.
 <br />
 <br />
 SYNOPSIS<br />
 <pre>
 struct cudaExtent {
     size_t width, height, depth;
 };
 </pre>
 <pre>
 struct cudaPos {
     size_t x, y, z;
 };
 </pre>
 <pre>
 struct cudaMemcpy3DParms {
     struct cudaArray *srcArray;
     struct cudaPos srcPos;
     struct cudaPitchedPtr srcPtr;
     struct cudaArray *dstArray;
     struct cudaPos dstPos;
     struct cudaPitchedPtr dstPtr;
     struct cudaExtent extent;
     enum cudaMemcpyKind kind;
 };
 </pre>
 cudaError_t cudaMemcpy3D( const struct cudaMemcpy3DParms *p )
 cudaError_t cudaMemcpy3DAsync( const struct cudaMemcpy3DParms *p, cudaStream_t stream )
 <br />
 <br />
 DESCRIPTION<br />
 cudaMemcpy3D() copies data between two 3D objects. The source and destination objects may be in
 either host memory, device memory, or a CUDA array. The source, destination, extent, and kind of copy
 performed is specified by the cudaMemcpy3DParms struct which should be initialized to zero before use:
 cudaMemcpy3DParms myParms = {0};
 </pre>
 The struct passed to cudaMemcpy3D() must specify one of srcArray or srcPtr and one of dstArray or
 dstPtr. Passing more than one non-zero source or destination will cause cudaMemcpy3D() to return an
 error.
 The srcPos and dstPos fields are optional offsets into the source and destination objects and are defined in
 units of each objects elements. The element for a host or device pointer is assumed to be unsigned char.
 For CUDA arrays, positions must be in the range [0, 2048) for any dimension.
 The extent field defines the dimensions of the transferred area in elements. If a CUDA array is participating
 in the copy the extent is defined in terms of that arrays elements. If no CUDA array is participating in the
 copy then the extents are defined in elements of unsigned char.
 The kind field defines the direction of the copy. It must be one of cudaMemcpyHostToHost, cudaMem-
 cpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice.
 If the source and destination are both arrays cudaMemcpy3D() will return an error if they do not have
 the same element size.
 The source and destination object may not overlap. If overlapping source and destination objects are specified
 undefined behavior will result.
 cudaMemcpy3D() returns an error if the pitch of srcPtr or dstPtr is greater than the maximum allowed.
 The pitch of a cudaPitchedPtr allocated with cudaMalloc3D() will always be valid.
 cudaMemcpy3DAsync() is an asynchronous copy operation and can optionally be associated to a stream
 by passing a non-zero stream argument. If either the source or destination is a host object it must be
 allocated in page-locked memory returned from cudaMallocHost(). It will return an error if a pointer to
 memory not allocated with cudaMallocHost() is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3D(jcuda.runtime.cudaPitchedPtr, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)"><CODE>cudaMalloc3DArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy3DAsync(jcuda.runtime.cudaMemcpy3DParms, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy3DAsync</H3>
<PRE>
public static int <B>cudaMemcpy3DAsync</B>(<A HREF="../../jcuda/runtime/cudaMemcpy3DParms.html" title="class in jcuda.runtime">cudaMemcpy3DParms</A>&nbsp;p,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)"><CODE>cudaMemcpy3D(jcuda.runtime.cudaMemcpy3DParms)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostAlloc(jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaHostAlloc</H3>
<PRE>
public static int <B>cudaHostAlloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                                long&nbsp;size,
                                int&nbsp;flags)</PRE>
<DL>
<DD>Allocates count bytes of host memory that is page-locked and accessible to the device. The driver tracks the virtual
 memory ranges allocated with this function and automatically accelerates calls to functions such as cudaMemcpy().
 Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than
 pageable memory obtained with functions such as malloc(). Allocating excessive amounts of pinned memory may
 degrade system performance, since it reduces the amount of memory available to the system for paging. As a result,
 this function is best used sparingly to allocate staging areas for data exchange between host and device.<br />
 <br />
 The flags parameter enables different options to be specified that affect the allocation, as follows.
 - cudaHostAllocDefault: This flags value is defined to be 0 and causes cudaHostAlloc() to emulate cudaMallocHost().<br />
 - cudaHostAllocPortable: The memory returned by this call will be considered as pinned memory by all CUDA
 contexts, not just the one that performed the allocation.<br />
 - cudaHostAllocMapped: Maps the allocation into the CUDA address space. The device pointer to the memory
 may be obtained by calling cudaHostGetDevicePointer().<br />
 - cudaHostAllocWriteCombined: Allocates the memory as write-combined (WC). WC memory can be transferred
 across the PCI Express bus more quickly on some system configurations, but cannot be read efficiently
 by most CPUs. WC memory is a good option for buffers that will be written by the CPU and read by the device
 via mapped pinned memory or host->device transfers.<br />
 <br />
 All of these flags are orthogonal to one another: a developer may allocate memory that is portable, mapped and/or
 write-combined with no restrictions.<br />
 <br />
 cudaSetDeviceFlags() must have been called with the cudaDeviceMapHost flag in order for the cudaHostAllocMapped
 flag to have any effect.<br />
 <br />
 The cudaHostAllocMapped flag may be specified on CUDA contexts for devices that do not support mapped pinned
 memory. The failure is deferred to cudaHostGetDevicePointer() because the memory may be mapped into other
 CUDA contexts via the cudaHostAllocPortable flag.<br />
 <br />
 Memory allocated by this function must be freed with cudaFreeHost().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptr</CODE> - - Device pointer to allocated memory<DD><CODE>size</CODE> - - Requested allocation size in bytes<DD><CODE>flags</CODE> - - Requested properties of allocated memory
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaSetDeviceFlags(int)"><CODE>cudaSetDeviceFlags(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaHostGetDevicePointer(jcuda.Pointer, jcuda.Pointer, int)"><!-- --></A><H3>
cudaHostGetDevicePointer</H3>
<PRE>
public static int <B>cudaHostGetDevicePointer</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pDevice,
                                           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;pHost,
                                           int&nbsp;flags)</PRE>
<DL>
<DD>Passes back the device pointer corresponding to the mapped, pinned host buffer allocated by cudaHostAlloc().
 cudaHostGetDevicePointer() will fail if the cudaDeviceMapHost flag was not specified before deferred context creation
 occurred, or if called on a device that does not support mapped, pinned memory.
 flags provides for future releases. For now, it must be set to 0.
 Parameters:
 pDevice - Returned device pointer for mapped memory
 pHost - Requested host pointer mapping
 flags - Flags for extensions (must be 0 for now)
 Returns:
 cudaSuccess, cudaErrorInvalidValue, cudaErrorMemoryAllocation
 Note:
 Note that this function may also return error codes from previous, asynchronous launches.
 See also:
 cudaSetDeviceFlags, cudaHostAlloc
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cudaMalloc(jcuda.Pointer, long)"><!-- --></A><H3>
cudaMalloc</H3>
<PRE>
public static int <B>cudaMalloc</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                             long&nbsp;size)</PRE>
<DL>
<DD>Allocate memory on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMalloc( void** devPtr, size_t count )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates count bytes of linear memory on the device and returns in *devPtr a pointer to the allocated
 memory. The allocated memory is suitably aligned for any kind of variable. The memory is not cleared.
 cudaMalloc() returns cudaErrorMemoryAllocation in case of failure.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocHost(jcuda.Pointer, long)"><!-- --></A><H3>
cudaMallocHost</H3>
<PRE>
public static int <B>cudaMallocHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr,
                                 long&nbsp;size)</PRE>
<DL>
<DD>Allocates page-locked memory on the host.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMallocHost( void** hostPtr, size_t size )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates size bytes of host memory that is page-locked and accessible to the device. The driver tracks
 the virtual memory ranges allocated with this function and automatically accelerates calls to functions such
 as cudaMemcpy*(). Since the memory can be accessed directly by the device, it can be read or written
 with much higher bandwidth than pageable memory obtained with functions such as malloc(). Allocating
 excessive amounts of memory with cudaMallocHost() may degrade system performance, since it reduces
 the amount of memory available to the system for paging. As a result, this function is best used sparingly
 to allocate staging areas for data exchange between host and device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocPitch(jcuda.Pointer, long[], long, long)"><!-- --></A><H3>
cudaMallocPitch</H3>
<PRE>
public static int <B>cudaMallocPitch</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                  long[]&nbsp;pitch,
                                  long&nbsp;width,
                                  long&nbsp;height)</PRE>
<DL>
<DD>Allocates memory on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMallocPitch( void** devPtr, size_t* pitch, size_t widthInBytes, size_t height
 )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates at least widthInBytes*height bytes of linear memory on the device and returns in *devPtr
 a pointer to the allocated memory. The function may pad the allocation to ensure that corresponding
 pointers in any given row will continue to meet the alignment requirements for coalescing as the address is
 updated from row to row. The pitch returned in *pitch by cudaMallocPitch() is the width in bytes of
 the allocation. The intended usage of pitch is as a separate parameter of the allocation, used to compute
 addresses within the 2D array. Given the row and column of an array element of type T, the address is
 computed as<br />
 T* pElement = (T*)((char*)BaseAddress + Row * pitch) + Column;<br />
 For allocations of 2D arrays, it is recommended that programmers consider performing pitch allocations
 using cudaMallocPitch(). Due to pitch alignment restrictions in the hardware, this is especially true if
 the application will be performing 2D memory copies between different regions of device memory (whether
 linear memory or CUDA arrays).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><!-- --></A><H3>
cudaMallocArray</H3>
<PRE>
public static int <B>cudaMallocArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                  long&nbsp;width,
                                  long&nbsp;height)</PRE>
<DL>
<DD>Allocate an array on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMallocArray( struct cudaArray** array, const struct cudaChannelFormatDesc*
 desc, size_t width, size_t height )
 <br />
 <br />
 DESCRIPTION<br />
 Allocates a CUDA array according to the cudaChannelFormatDesc structure desc and returns a handle
 to the new CUDA array in *array. The cudaChannelFormatDesc is defined as:
 <pre>
 struct cudaChannelFormatDesc {
     int x, y, z, w;
     enum cudaChannelFormatKind f;
 };
 </pre>
 where cudaChannelFormatKind is one of cudaChannelFormatKindSigned, cudaChannelFormatKin-
 dUnsigned, cudaChannelFormatKindFloat.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFree(jcuda.Pointer)"><!-- --></A><H3>
cudaFree</H3>
<PRE>
public static int <B>cudaFree</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr)</PRE>
<DL>
<DD>Frees memory on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaFree(void* devPtr)
 <br />
 <br />
 DESCRIPTION<br />
 Frees the memory space pointed to by devPtr, which must have been returned by a previous call to cud-
 aMalloc() or cudaMallocPitch(). Otherwise, or if cudaFree(devPtr) has already been called before,
 an error is returned. If devPtr is 0, no operation is performed. cudaFree() returns cudaErrorInvalid-
 DevicePointer in case of failure.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer, cudaErrorInitializationError,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFreeHost(jcuda.Pointer)"><!-- --></A><H3>
cudaFreeHost</H3>
<PRE>
public static int <B>cudaFreeHost</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;ptr)</PRE>
<DL>
<DD>Frees page-locked memory.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaFreeHost( void* hostPtr )
 <br />
 <br />
 DESCRIPTION<br />
 Frees the memory space pointed to by hostPtr, which must have been returned by a previous call to
 cudaMallocHost().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeArray(jcuda.runtime.cudaArray)"><CODE>cudaFreeArray(jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFreeArray(jcuda.runtime.cudaArray)"><!-- --></A><H3>
cudaFreeArray</H3>
<PRE>
public static int <B>cudaFreeArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</PRE>
<DL>
<DD>Frees an array on the GPU.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaFreeArray( struct cudaArray* array )
 <br />
 <br />
 DESCRIPTION<br />
 Frees the CUDA array array. If array is 0, no operation is performed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMalloc(jcuda.Pointer, long)"><CODE>cudaMalloc(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocPitch(jcuda.Pointer, long[], long, long)"><CODE>cudaMallocPitch(jcuda.Pointer, long[], long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFree(jcuda.Pointer)"><CODE>cudaFree(jcuda.Pointer)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)"><CODE>cudaMallocArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMallocHost(jcuda.Pointer, long)"><CODE>cudaMallocHost(jcuda.Pointer, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaFreeHost(jcuda.Pointer)"><CODE>cudaFreeHost(jcuda.Pointer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaMemcpy</H3>
<PRE>
public static int <B>cudaMemcpy</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                             <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                             long&nbsp;count,
                             int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between GPU and host.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpy( void* dst, const void* src, size_t count, enum cudaMemcpyKind kind
 )
 cudaError_t cudaMemcpyAsync( void* dst, const void* src, size_t count, enum cudaMemcpyKind
 kind, cudaStream_t stream )
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the memory area pointed to by src to the memory area pointed to by dst,
 where kind is one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDevice-
 ToHost, or cudaMemcpyDeviceToDevice, and specifies the direction of the copy. The memory areas
 may not overlap. Calling cudaMemcpy() with dst and src pointers that do not match the direction of the
 copy results in an undefined behavior.
 cudaMemcpyAsync() is asynchronous and can optionally be associated to a stream by passing a non-zero
 stream argument. It only works on page-locked host memory and returns an error if a pointer to pageable
 memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><!-- --></A><H3>
cudaMemcpyToArray</H3>
<PRE>
public static int <B>cudaMemcpyToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                    long&nbsp;wOffset,
                                    long&nbsp;hOffset,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                    long&nbsp;count,
                                    int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpyToArray(struct cudaArray* dstArray, size_t dstX, size_t dstY, const void*
 src, size_t count, enum cudaMemcpyKind kind)
 cudaError_t cudaMemcpyToArrayAsync(struct cudaArray* dstArray, size_t dstX, size_t dstY, const
 void* src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream)
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the memory area pointed to by src to the CUDA array dstArray starting at the
 upper left corner (dstX, dstY), where kind is one of cudaMemcpyHostToHost, cudaMemcpyHost-
 ToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the direction
 of the copy.
 cudaMemcpyToArrayAsync() is asynchronous and can optionally be associated to a stream by passing
 a non-zero stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><!-- --></A><H3>
cudaMemcpyFromArray</H3>
<PRE>
public static int <B>cudaMemcpyFromArray</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                      <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                      long&nbsp;wOffset,
                                      long&nbsp;hOffset,
                                      long&nbsp;count,
                                      int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpyFromArray(void* dst, const struct cudaArray* srcArray, size_t srcX, size_t
 srcY, size_t count, enum cudaMemcpyKind kind)
 cudaError_t cudaMemcpyFromArrayAsync(void* dst, const struct cudaArray* srcArray, size_t srcX,
 size_t srcY, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream)
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the CUDA array srcArray starting at the upper left corner (srcX, srcY) to the
 memory area pointed to by dst, where kind is one of cudaMemcpyHostToHost, cudaMemcpyHost-
 ToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the direction
 of the copy.
 cudaMemcpyFromArrayAsync() is asynchronous and can optionally be associated to a stream by passing
 a non-zero stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><!-- --></A><H3>
cudaMemcpyArrayToArray</H3>
<PRE>
public static int <B>cudaMemcpyArrayToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                         long&nbsp;wOffsetDst,
                                         long&nbsp;hOffsetDst,
                                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                         long&nbsp;wOffsetSrc,
                                         long&nbsp;hOffsetSrc,
                                         long&nbsp;count,
                                         int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpyArrayToArray(struct cudaArray* dstArray, size_t dstX, size_t dstY, const
 struct cudaArray* srcArray, size_t srcX, size_t srcY, size_t count, enum cudaMemcpyKind kind)
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the CUDA array srcArray starting at the upper left corner (srcX, srcY) to the
 CUDA array dstArray starting at the upper left corner (dstX, dstY), where kind is one of cudaMem-
 cpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDe-
 viceToDevice, and specifies the direction of the copy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2D</H3>
<PRE>
public static int <B>cudaMemcpy2D</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                               long&nbsp;dpitch,
                               <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                               long&nbsp;spitch,
                               long&nbsp;width,
                               long&nbsp;height,
                               int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpy2D( void* dst, size_t dpitch, const void* src, size_t spitch, size_t
 width, size_t height, enum cudaMemcpyKind kind )
 cudaError_t cudaMemcpy2DAsync( void* dst, size_t dpitch, const void* src, size_t spitch, size_t
 width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream )
 <br />
 <br />
 DESCRIPTION<br />
 Copies a matrix (height rows of width bytes each) from the memory area pointed to by src to the memory
 area pointed to by dst, where kind is one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice,
 cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
 dpitch and spitch are the widths in memory in bytes of the 2D arrays pointed to by dst and src, including
 any padding added to the end of each row. The memory areas may not overlap. Calling cudaMemcpy2D()
 with dst and src pointers that do not match the direction of the copy results in an undefined behavior.
 cudaMemcpy2D() returns an error if dpitch or spitch is greater than the maximum allowed.
 cudaMemcpy2DAsync() is asynchronous and can optionally be associated to a stream by passing a non-
 zero stream argument. It only works on page-locked host memory and returns an error if a pointer to
 pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidPitchValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DToArray</H3>
<PRE>
public static int <B>cudaMemcpy2DToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                      long&nbsp;wOffset,
                                      long&nbsp;hOffset,
                                      <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                      long&nbsp;spitch,
                                      long&nbsp;width,
                                      long&nbsp;height,
                                      int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpy2DToArray(struct cudaArray* dstArray, size_t dstX, size_t dstY, const
 void* src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind); cudaError_t
 cudaMemcpy2DToArrayAsync(struct cudaArray* dstArray, size_t dstX, size_t dstY, const void*
 src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
 <br />
 <br />
 DESCRIPTION<br />
 Copies a matrix (height rows of width bytes each) from the memory area pointed to by src to the CUDA
 array dstArray starting at the upper left corner (dstX, dstY), where kind is one of cudaMemcpyHost-
 ToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDe-
 vice, and specifies the direction of the copy. spitch is the width in memory in bytes of the 2D array pointed
 to by src, including any padding added to the end of each row. cudaMemcpy2D() returns an error if
 spitch is greater than the maximum allowed.
 cudaMemcpy2DToArrayAsync() is asynchronous and can optionally be associated to a stream by pass-
 ing a non-zero stream argument. It only works on page-locked host memory and returns an error if a pointer
 to pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DFromArray</H3>
<PRE>
public static int <B>cudaMemcpy2DFromArray</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                        long&nbsp;dpitch,
                                        <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                        long&nbsp;wOffset,
                                        long&nbsp;hOffset,
                                        long&nbsp;width,
                                        long&nbsp;height,
                                        int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpy2DFromArray(void* dst, size_t dpitch, const struct cudaArray* srcArray,
 size_t srcX, size_t srcY, size_t width, size_t height, enum cudaMemcpyKind kind)
 cudaError_t cudaMemcpy2DFromArrayAsync(void* dst, size_t dpitch, const struct cudaArray* srcArray,
 size_t srcX, size_t srcY, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t
 stream)
 <br />
 <br />
 DESCRIPTION<br />
 Copies a matrix (height rows of width bytes each) from the CUDA array srcArray starting at the upper
 left corner (srcX, srcY) to the memory area pointed to by dst, where kind is one of cudaMemcpyHost-
 ToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost, or cudaMemcpyDeviceToDe-
 vice, and specifies the direction of the copy. dpitch is the width in memory in bytes of the 2D array pointed
 to by dst, including any padding added to the end of each row. cudaMemcpy2D() returns an error if
 dpitch is greater than the maximum allowed.
 cudaMemcpy2DFromArrayAsync() is asynchronous and can optionally be associated to a stream by
 passing a non-zero stream argument. It only works on page-locked host memory and returns an error if a
 pointer to pageable memory is passed as input.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidPitchValue, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><!-- --></A><H3>
cudaMemcpy2DArrayToArray</H3>
<PRE>
public static int <B>cudaMemcpy2DArrayToArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                           long&nbsp;wOffsetDst,
                                           long&nbsp;hOffsetDst,
                                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                           long&nbsp;wOffsetSrc,
                                           long&nbsp;hOffsetSrc,
                                           long&nbsp;width,
                                           long&nbsp;height,
                                           int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data between host and device.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemcpy2DArrayToArray(struct cudaArray* dstArray, size_t dstX, size_t dstY,
 const struct cudaArray* srcArray, size_t srcX, size_t srcY, size_t width, size_t height, enum
 cudaMemcpyKind kind)
 <br />
 <br />
 DESCRIPTION<br />
 Copies a matrix (height rows of width bytes each) from the CUDA array srcArray starting at the upper
 left corner (srcX, srcY) to the CUDA array dstArray starting at the upper left corner (dstX, dstY),
 where kind is one of cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDevice-
 ToHost, or cudaMemcpyDeviceToDevice, and specifies the direction of the copy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><!-- --></A><H3>
cudaMemcpyToSymbol</H3>
<PRE>
public static int <B>cudaMemcpyToSymbol</B>(java.lang.String&nbsp;symbol,
                                     <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                     long&nbsp;count,
                                     long&nbsp;offset,
                                     int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data from host memory to GPU.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T &gt;
 cudaError_t cudaMemcpyToSymbol( const T&amp; symbol, const void* src, size_t count, size_t offset,
 enum cudaMemcpyKind kind)
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the memory area pointed to by src to the memory area pointed to by offset
 bytes from the start of symbol symbol. The memory areas may not overlap. symbol can either be a
 variable that resides in global or constant memory space, or it can be a character string, naming a vari-
 able that resides in global or constant memory space. kind can be either cudaMemcpyHostToDevice or
 cudaMemcpyDeviceToDevice.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><!-- --></A><H3>
cudaMemcpyFromSymbol</H3>
<PRE>
public static int <B>cudaMemcpyFromSymbol</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                       java.lang.String&nbsp;symbol,
                                       long&nbsp;count,
                                       long&nbsp;offset,
                                       int&nbsp;cudaMemcpyKind_kind)</PRE>
<DL>
<DD>Copies data from GPU to host memory.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T &gt;
 cudaError_t cudaMemcpyFromSymbol( void *dst, const T&amp; symbol, size_t count, size_t offset,
 enum cudaMemcpyKind kind)
 <br />
 <br />
 DESCRIPTION<br />
 Copies count bytes from the memory area pointed to by offset bytes from the start of symbol symbol
 to the memory area pointed to by dst. The memory areas may not overlap. symbol can either be a
 variable that resides in global or constant memory space, or it can be a character string, naming a vari-
 able that resides in global or constant memory space. kind can be either cudaMemcpyDeviceToHost or
 cudaMemcpyDeviceToDevice.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidSymbol, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DArrayToArray(jcuda.runtime.cudaArray, long, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyAsync(jcuda.Pointer, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyAsync</H3>
<PRE>
public static int <B>cudaMemcpyAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                  long&nbsp;count,
                                  int&nbsp;cudaMemcpyKind_kind,
                                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)"><CODE>cudaMemcpy(jcuda.Pointer, jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyToArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpyToArrayAsync</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                         long&nbsp;wOffset,
                                         long&nbsp;hOffset,
                                         <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                         long&nbsp;count,
                                         int&nbsp;cudaMemcpyKind_kind,
                                         <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)"><CODE>cudaMemcpyToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromArrayAsync(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyFromArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpyFromArrayAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                           <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                           long&nbsp;wOffset,
                                           long&nbsp;hOffset,
                                           long&nbsp;count,
                                           int&nbsp;cudaMemcpyKind_kind,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)"><CODE>cudaMemcpyFromArray(jcuda.Pointer, jcuda.runtime.cudaArray, long, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DAsync(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                    long&nbsp;dpitch,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                    long&nbsp;spitch,
                                    long&nbsp;width,
                                    long&nbsp;height,
                                    int&nbsp;cudaMemcpyKind_kind,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2D(jcuda.Pointer, long, jcuda.Pointer, long, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DToArrayAsync(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DToArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DToArrayAsync</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;dst,
                                           long&nbsp;wOffset,
                                           long&nbsp;hOffset,
                                           <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                           long&nbsp;spitch,
                                           long&nbsp;width,
                                           long&nbsp;height,
                                           int&nbsp;cudaMemcpyKind_kind,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)"><CODE>cudaMemcpy2DToArray(jcuda.runtime.cudaArray, long, long, jcuda.Pointer, long, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpy2DFromArrayAsync(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpy2DFromArrayAsync</H3>
<PRE>
public static int <B>cudaMemcpy2DFromArrayAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                             long&nbsp;dpitch,
                                             <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;src,
                                             long&nbsp;wOffset,
                                             long&nbsp;hOffset,
                                             long&nbsp;width,
                                             long&nbsp;height,
                                             int&nbsp;cudaMemcpyKind_kind,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)"><CODE>cudaMemcpy2DFromArray(jcuda.Pointer, long, jcuda.runtime.cudaArray, long, long, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyToSymbolAsync(java.lang.String, jcuda.Pointer, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyToSymbolAsync</H3>
<PRE>
public static int <B>cudaMemcpyToSymbolAsync</B>(java.lang.String&nbsp;symbol,
                                          <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;src,
                                          long&nbsp;count,
                                          long&nbsp;offset,
                                          int&nbsp;cudaMemcpyKind_kind,
                                          <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)"><CODE>cudaMemcpyToSymbol(java.lang.String, jcuda.Pointer, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemcpyFromSymbolAsync(jcuda.Pointer, java.lang.String, long, long, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaMemcpyFromSymbolAsync</H3>
<PRE>
public static int <B>cudaMemcpyFromSymbolAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;dst,
                                            java.lang.String&nbsp;symbol,
                                            long&nbsp;count,
                                            long&nbsp;offset,
                                            int&nbsp;cudaMemcpyKind_kind,
                                            <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)"><CODE>cudaMemcpyFromSymbol(jcuda.Pointer, java.lang.String, long, long, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset(jcuda.Pointer, int, long)"><!-- --></A><H3>
cudaMemset</H3>
<PRE>
public static int <B>cudaMemset</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
                             int&nbsp;c,
                             long&nbsp;count)</PRE>
<DL>
<DD>Initializes or sets GPU memory to a value.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemset( void* devPtr, int value, size_t count )
 <br />
 <br />
 DESCRIPTION<br />
 Fills the first count bytes of the memory area pointed to by devPtr with the constant byte value value.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset2D(jcuda.Pointer, long, int, long, long)"><CODE>cudaMemset2D(jcuda.Pointer, long, int, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaMemset2D(jcuda.Pointer, long, int, long, long)"><!-- --></A><H3>
cudaMemset2D</H3>
<PRE>
public static int <B>cudaMemset2D</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;mem,
                               long&nbsp;pitch,
                               int&nbsp;c,
                               long&nbsp;width,
                               long&nbsp;height)</PRE>
<DL>
<DD>Initializes or sets GPU memory to a value.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaMemset2D( void* dstPtr, size_t pitch, int value, size_t width, size_t height
 )
 <br />
 <br />
 DESCRIPTION<br />
 Sets to the specified value value a matrix (height rows of width bytes each) pointed to by dstPtr. pitch
 is the width in memory in bytes of the 2D array pointed to by dstPtr, including any padding added to
 the end of each row. This function performs fastest when the pitch is one that has been passed back by
 cudaMallocPitch().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaMemset(jcuda.Pointer, int, long)"><CODE>cudaMemset(jcuda.Pointer, int, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)"><CODE>cudaMemset3D(jcuda.runtime.cudaPitchedPtr, int, jcuda.runtime.cudaExtent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><!-- --></A><H3>
cudaGetChannelDesc</H3>
<PRE>
public static int <B>cudaGetChannelDesc</B>(<A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                     <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array)</PRE>
<DL>
<DD>Low-level texture API.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetChannelDesc(struct cudaChannelFormatDesc* desc, const struct cudaArray*
 array);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *desc the channel descriptor of the CUDA array array.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaCreateChannelDesc(int, int, int, int, int)"><!-- --></A><H3>
cudaCreateChannelDesc</H3>
<PRE>
public static <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A> <B>cudaCreateChannelDesc</B>(int&nbsp;x,
                                                          int&nbsp;y,
                                                          int&nbsp;z,
                                                          int&nbsp;w,
                                                          int&nbsp;cudaChannelFormatKind_f)</PRE>
<DL>
<DD>Returns a channel descriptor.
 <br />
 <br />
 SYNOPSIS<br />
 struct cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);<br />
 DESCRIPTION<br />
 Returns a channel descriptor with format f and number of bits of each component x, y, z, and w. The
 cudaChannelFormatDesc is defined as:
 <pre>
 struct cudaChannelFormatDesc {
     int x, y, z, w;
     enum cudaChannelFormatKind f;
 };
 </pre>
 where cudaChannelFormatKind is one of cudaChannelFormatKindSigned, cudaChannelFormatKindUnsigned,
 cudaChannelFormatKindFloat.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetLastError()"><!-- --></A><H3>
cudaGetLastError</H3>
<PRE>
public static int <B>cudaGetLastError</B>()</PRE>
<DL>
<DD>Returns the last error from a run-time call.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetLastError( void )
 <br />
 <br />
 DESCRIPTION<br />
 Returns the last error that was returned from any of the runtime calls in the same host thread and resets it
 to cudaSuccess.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorLaunchFailure, cudaErrorPriorLaunchFailure, cudaErrorLaunchTimeout, cudaErrorLaunchOutOfResources, cudaErrorInvalidDeviceFunction, cudaErrorInvalidConfiguration, cudaErrorInvalidDevice, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture, cudaErrorInvalidTextureBinding, cudaErrorInvalidChannelDescriptor, cudaErrorTextureFetchFailed, cudaErrorTextureNotBound, cudaErrorSynchronizationError, cudaErrorUnknown, cudaErrorInvalidResourceHandle, cudaErrorNotReady, Note that this function may also return error codes from previous asynchronous launches., 95,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetErrorString(int)"><CODE>cudaGetErrorString(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/cudaError.html" title="class in jcuda.runtime"><CODE>cudaError</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetErrorString(int)"><!-- --></A><H3>
cudaGetErrorString</H3>
<PRE>
public static java.lang.String <B>cudaGetErrorString</B>(int&nbsp;error)</PRE>
<DL>
<DD>Returns the message string from an error.
 <br />
 <br />
 SYNOPSIS<br />
 const char* cudaGetErrorString(cudaError_t error);
 <br />
 <br />
 DESCRIPTION<br />
 Returns a message string from an error code.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The error string<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetLastError()"><CODE>cudaGetLastError()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamCreate(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamCreate</H3>
<PRE>
public static int <B>cudaStreamCreate</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Create an async stream.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaStreamCreate( cudaStream_t* stream )
 <br />
 <br />
 DESCRIPTION<br />
 Creates a stream.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamDestroy</H3>
<PRE>
public static int <B>cudaStreamDestroy</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Destroys and cleans-up a stream object.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaStreamDestroy( cudaStream_t stream )
 <br />
 <br />
 DESCRIPTION<br />
 Destroys a stream object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamSynchronize</H3>
<PRE>
public static int <B>cudaStreamSynchronize</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Waits for stream tasks to complete.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaStreamSynchronize( cudaStream_t stream )
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the device has completed all operations in the stream.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamQuery(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamQuery(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaStreamQuery(jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaStreamQuery</H3>
<PRE>
public static int <B>cudaStreamQuery</B>(<A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Queries a stream for completion-status.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaStreamQuery(cudaStream_t stream)
 <br />
 <br />
 DESCRIPTION<br />
 Returns cudaSuccess if all operations in the stream have completed, or cudaErrorNotReady if not.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotReady, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaStreamCreate(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamCreate(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamDestroy(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamDestroy(jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaStreamSynchronize(jcuda.runtime.cudaStream_t)"><CODE>cudaStreamSynchronize(jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventCreate(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventCreate</H3>
<PRE>
public static int <B>cudaEventCreate</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Creates an event-object.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventCreate( cudaEvent_t* event )
 <br />
 <br />
 DESCRIPTION<br />
 Creates an event object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue, cudaErrorMemoryAllocation,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><CODE>cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventCreateWithFlags(jcuda.runtime.cudaEvent_t, int)"><!-- --></A><H3>
cudaEventCreateWithFlags</H3>
<PRE>
public static int <B>cudaEventCreateWithFlags</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                           int&nbsp;flags)</PRE>
<DL>
<DD>Creates an event object with the specified flags.
 Valid flags include: cudaEventDefault, cudaEventBlockingSync
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>event</CODE> - - Newly created event<DD><CODE>flags</CODE> - - Flags for new event
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue, cudaErrorMemoryAllocation<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaEventRecord</H3>
<PRE>
public static int <B>cudaEventRecord</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event,
                                  <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Records an event.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventRecord( cudaEvent_t event, CUstream stream )
 <br />
 <br />
 DESCRIPTION<br />
 Records an event. If stream is non-zero, the event is recorded after all preceding operations in the stream
 have been completed; otherwise, it is recorded after all preceding operations in the CUDA context have been
 completed. Since this operation is asynchronous, cudaEventQuery() and/or cudaEventSynchronize()
 must be used to determine when the event has actually been recorded.
 If cudaEventRecord() has previously been called and the event has not been recorded yet, this function
 returns cudaErrorInvalidValue.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventQuery(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventQuery</H3>
<PRE>
public static int <B>cudaEventQuery</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Query if an event has been recorded.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventQuery( cudaEvent_t event )
 <br />
 <br />
 DESCRIPTION<br />
 Returns cudaSuccess if the event has actually been recorded, or cudaErrorNotReady if not. If cud-
 aEventRecord() has not been called on this event, the function returns cudaErrorInvalidValue.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotReady, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventSynchronize</H3>
<PRE>
public static int <B>cudaEventSynchronize</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Wait for an event to be recorded.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventSynchronize( cudaEvent_t event )
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the event has actually been recorded. If cudaEventRecord() has not been called on this
 event, the function returns cudaErrorInvalidValue.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventDestroy</H3>
<PRE>
public static int <B>cudaEventDestroy</B>(<A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;event)</PRE>
<DL>
<DD>Destroys an event-object.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventDestroy( cudaEvent_t event )
 <br />
 <br />
 DESCRIPTION<br />
 Destroys the event-object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><CODE>cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaEventElapsedTime(float[], jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaEvent_t)"><!-- --></A><H3>
cudaEventElapsedTime</H3>
<PRE>
public static int <B>cudaEventElapsedTime</B>(float[]&nbsp;ms,
                                       <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;start,
                                       <A HREF="../../jcuda/runtime/cudaEvent_t.html" title="class in jcuda.runtime">cudaEvent_t</A>&nbsp;end)</PRE>
<DL>
<DD>Computes the elapsed time between events.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaEventElapsedTime( float* time, cudaEvent_t start, cudaEvent_t end );
 <br />
 <br />
 DESCRIPTION<br />
 Computes the elapsed time between two events (in milliseconds with a resolution of around 0.5 microseconds).
 If either event has not been recorded yet, this function returns cudaErrorInvalidValue. If either event
 has been recorded with a non-zero stream, the result is undefined.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInitializationError, cudaErrorPriorLaunchFailure, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaEventCreate(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventCreate(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventQuery(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventQuery(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventSynchronize(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventSynchronize(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventDestroy(jcuda.runtime.cudaEvent_t)"><CODE>cudaEventDestroy(jcuda.runtime.cudaEvent_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)"><CODE>cudaEventRecord(jcuda.runtime.cudaEvent_t, jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadExit()"><!-- --></A><H3>
cudaThreadExit</H3>
<PRE>
public static int <B>cudaThreadExit</B>()</PRE>
<DL>
<DD>Exit and clean-up from CUDA launches.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaThreadExit(void)
 <br />
 <br />
 DESCRIPTION<br />
 Explicitly cleans up all runtime-related resources associated with the calling host thread. Any subsequent
 API call reinitializes the runtime. cudaThreadExit() is implicitly called on host thread exit.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadSynchronize()"><CODE>cudaThreadSynchronize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaThreadSynchronize()"><!-- --></A><H3>
cudaThreadSynchronize</H3>
<PRE>
public static int <B>cudaThreadSynchronize</B>()</PRE>
<DL>
<DD>Wait for compute-device to finish.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaThreadSynchronize(void)
 <br />
 <br />
 DESCRIPTION<br />
 Blocks until the device has completed all preceding requested tasks. cudaThreadSynchronize() returns
 an error if one of the preceding tasks failed.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaThreadExit()"><CODE>cudaThreadExit()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)"><!-- --></A><H3>
cudaGetSymbolAddress</H3>
<PRE>
public static int <B>cudaGetSymbolAddress</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                       java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Finds the address associated with a CUDA symbol.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T &gt;
 cudaError_t cudaGetSymbolAddress(void** devPtr, const T&amp; symbol)
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *devPtr the address of symbol symbol on the device. symbol can either be a variable that
 resides in global memory space, or it can be a character string, naming a variable that resides in global
 memory space. If symbol cannot be found, or if symbol is not declared in global memory space, *devPtr
 is unchanged and an error is returned. cudaGetSymbolAddress() returns cudaErrorInvalidSymbol in
 case of failure
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidSymbol, cudaErrorAddressOfConstant,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolSize(long[], java.lang.String)"><CODE>cudaGetSymbolSize(long[], java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetSymbolSize(long[], java.lang.String)"><!-- --></A><H3>
cudaGetSymbolSize</H3>
<PRE>
public static int <B>cudaGetSymbolSize</B>(long[]&nbsp;size,
                                    java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Finds the size of the object associated with a CUDA symbol.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T &gt;
 cudaError_t cudaGetSymbolSize(size_t* size, const T&amp; symbol)
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *size the size of symbol symbol. symbol can either be a variable that resides in global or
 constant memory space, or it can be a character string, naming a variable that resides in global or constant
 memory space. If symbol cannot be found, or if symbol is not declared in global or constant memory space,
 *size is unchanged and an error is returned. cudaGetSymbolSize() returns cudaErrorInvalidSymbol
 in case of failure.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidSymbol,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)"><CODE>cudaGetSymbolAddress(jcuda.Pointer, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><!-- --></A><H3>
cudaBindTexture</H3>
<PRE>
public static int <B>cudaBindTexture</B>(long[]&nbsp;offset,
                                  <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                  <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                  <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                  long&nbsp;size)</PRE>
<DL>
<DD>Binds size bytes of the memory area pointed to by devPtr to texture reference texRef.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T, int dim, enum cudaTextureReadMode readMode &gt;
 static __inline__ __host__ cudaError_t cudaBindTexture(size_t* offset, const struct texture
 &lt; T, dim, readMode &gt;&amp; texRef, const void* devPtr, const struct cudaChannelFormatDesc&amp; desc,
 size_t size = UINT_MAX)
 <br />
 <br />
 DESCRIPTION<br />
 Binds size bytes of the memory area pointed to by devPtr to texture reference texRef. desc describes
 how the memory is interpreted when fetching values from the texture. The offset parameter is an optional
 byte offset as with the low-level cudaBindTexture() function. Any memory previously bound to texRef
 is unbound.
 template E&lt;lt&gt; class T, int dim, enum cudaTextureReadMode readMode E&lt;gt&gt;
 static __inline__ __host__ cudaError_t cudaBindTexture(
 size_t* offset,
 const struct texture E&lt;lt&gt; T, dim, readMode E&lt;gt&gt;&amp; texRef,
 const void* devPtr,
 size_t size = UINT_MAX);
 binds size bytes of the memory area pointed to by devPtr to texture reference texRef. The channel descriptor
 is inherited from the texture reference type. The offset parameter is an optional byte offset as with the low-
 level cudaBindTexture() function described
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture,</DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><!-- --></A><H3>
cudaBindTexture2D</H3>
<PRE>
public static int <B>cudaBindTexture2D</B>(long[]&nbsp;offset,
                                    <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                    <A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                    <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc,
                                    long&nbsp;width,
                                    long&nbsp;height,
                                    long&nbsp;pitch)</PRE>
<DL>
<DD>Binds the 2D memory area pointed to by devPtr to the texture reference texref. The size of the area is constrained
 by width in texel units, height in texel units, and pitch in byte units. desc describes how the memory is
 interpreted when fetching values from the texture. Any memory previously bound to texref is unbound.
 Since the hardware enforces an alignment requirement on texture base addresses, cudaBindTexture2D() returns in
 offset a byte offset that must be applied to texture fetches in order to read from the desired memory. This offset
 must be divided by the texel size and passed to kernels that read from the texture so they can be applied to the tex2D()
 function. If the device memory pointer was returned from cudaMalloc(), the offset is guaranteed to be 0 and NULL
 may be passed as the offset parameter.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - - Offset in bytes<DD><CODE>texref</CODE> - - Texture reference to bind<DD><CODE>devPtr</CODE> - - 2D memory area on device<DD><CODE>desc</CODE> - - Channel format<DD><CODE>width</CODE> - - Width in texel units<DD><CODE>height</CODE> - - Height in texel units<DD><CODE>pitch</CODE> - - Pitch in bytes
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)"><CODE>cudaBindTexture2D(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long, long, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><!-- --></A><H3>
cudaBindTextureToArray</H3>
<PRE>
public static int <B>cudaBindTextureToArray</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                         <A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;array,
                                         <A HREF="../../jcuda/runtime/cudaChannelFormatDesc.html" title="class in jcuda.runtime">cudaChannelFormatDesc</A>&nbsp;desc)</PRE>
<DL>
<DD>Binds the CUDA array array to texture reference texRef.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T, int dim, enum cudaTextureReadMode readMode &gt;
 static __inline__ __host__ cudaError_t cudaBindTextureToArray( const struct texture &lt; T, dim,
 readMode &gt;&amp; texRef, const struct cudaArray* cuArray, const struct cudaChannelFormatDesc&amp; desc)
 <br />
 <br />
 DESCRIPTION<br />
 Binds the CUDA array array to texture reference texRef. desc describes how the memory is interpreted
 when fetching values from the texture. Any CUDA array previously bound to texRef is unbound.
 template E&lt;lt&gt; class T, int dim, enum cudaTextureReadMode readMode E&lt;gt&gt;
 static __inline__ __host__ cudaError_t cudaBindTextureToArray(
 const struct texture E&lt;lt&gt; T, dim, readMode E&lt;gt&gt;&amp; texRef,
 const struct cudaArray* cuArray);
 binds the CUDA array array to texture reference texRef. The channel descriptor is inherited from the
 CUDA array. Any CUDA array previously bound to texRef is unbound.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidTexture,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaUnbindTexture(jcuda.runtime.textureReference)"><!-- --></A><H3>
cudaUnbindTexture</H3>
<PRE>
public static int <B>cudaUnbindTexture</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</PRE>
<DL>
<DD>Unbinds the texture bound to texture reference texRef.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T, int dim, enum cudaTextureReadMode readMode &gt;
 static __inline__ __host__ cudaError_t cudaUnbindTexture(const struct texture &lt; T, dim, readMode
 &gt;&amp; texRef)
 <br />
 <br />
 DESCRIPTION<br />
 Unbinds the texture bound to texture reference texRef.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,</DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><!-- --></A><H3>
cudaGetTextureAlignmentOffset</H3>
<PRE>
public static int <B>cudaGetTextureAlignmentOffset</B>(long[]&nbsp;offset,
                                                <A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref)</PRE>
<DL>
<DD>Returns in *offset the offset that was returned when texture reference texRef was bound.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetTextureAlignmentOffset(size_t* offset, const struct textureReference* texRef);
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *offset the offset that was returned when texture reference texRef was bound.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidTexture, cudaErrorInvalidTextureBinding,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><CODE>cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGetTextureReference(jcuda.runtime.textureReference, java.lang.String)"><!-- --></A><H3>
cudaGetTextureReference</H3>
<PRE>
public static int <B>cudaGetTextureReference</B>(<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime">textureReference</A>&nbsp;texref,
                                          java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Returns in *texRef the structure associated to the texture reference defined by symbol symbol.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGetTextureReference( struct textureReference** texRef, const char* symbol)
 <br />
 <br />
 DESCRIPTION<br />
 Returns in *texRef the structure associated to the texture reference defined by symbol symbol.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidTexture,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaCreateChannelDesc(int, int, int, int, int)"><CODE>cudaCreateChannelDesc(int, int, int, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)"><CODE>cudaGetChannelDesc(jcuda.runtime.cudaChannelFormatDesc, jcuda.runtime.cudaArray)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)"><CODE>cudaBindTexture(long[], jcuda.runtime.textureReference, jcuda.Pointer, jcuda.runtime.cudaChannelFormatDesc, long)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)"><CODE>cudaBindTextureToArray(jcuda.runtime.textureReference, jcuda.runtime.cudaArray, jcuda.runtime.cudaChannelFormatDesc)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaUnbindTexture(jcuda.runtime.textureReference)"><CODE>cudaUnbindTexture(jcuda.runtime.textureReference)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)"><CODE>cudaGetTextureAlignmentOffset(long[], jcuda.runtime.textureReference)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaConfigureCall</H3>
<PRE>
public static int <B>cudaConfigureCall</B>(<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;gridDim,
                                    <A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime">dim3</A>&nbsp;blockDim,
                                    long&nbsp;sharedMem,
                                    <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Configure a device-launch.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, int tokens
 = 0)
 <br />
 <br />
 DESCRIPTION<br />
 Specifies the grid and block dimensions for the device call to be executed similar to the execution configuration
 syntax. cudaConfigureCall() is stack based. Each call pushes data on top of an execution stack. This
 data contains the dimension for the grid and thread blocks, together with any arguments for the call.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidConfiguration,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaSetupArgument(jcuda.Pointer, long, long)"><!-- --></A><H3>
cudaSetupArgument</H3>
<PRE>
public static int <B>cudaSetupArgument</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;arg,
                                    long&nbsp;size,
                                    long&nbsp;offset)</PRE>
<DL>
<DD>Configure a device-launch.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaSetupArgument(void* arg, size_t count, size_t offset)
 template &lt; class T &gt; cudaError_t cudaSetupArgument(T arg, size_t offset)
 <br />
 <br />
 DESCRIPTION<br />
 Pushes count bytes of the argument pointed to by arg at offset bytes from the start of the parameter
 passing area, which starts at offset 0. The arguments are stored in the top of the execution stack. cudaSe-
 tupArgument() must be preceded by a call to cudaConfigureCall().
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><CODE>cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaFuncGetAttributes(jcuda.runtime.cudaFuncAttributes, java.lang.String)"><!-- --></A><H3>
cudaFuncGetAttributes</H3>
<PRE>
public static int <B>cudaFuncGetAttributes</B>(<A HREF="../../jcuda/runtime/cudaFuncAttributes.html" title="class in jcuda.runtime">cudaFuncAttributes</A>&nbsp;attr,
                                        java.lang.String&nbsp;func)</PRE>
<DL>
<DD>This function obtains the attributes of a function specified via func. The fetched attributes are placed in attr. If the
 specified function does not exist, then :cudaErrorInvalidDeviceFunction is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>attr</CODE> - - Return pointer to functions attributes<DD><CODE>func</CODE> - - Function to get attributes of
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInitializationError, cudaErrorInvalidDeviceFunction<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaLaunch(java.lang.String)"><CODE>cudaLaunch(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaLaunch(java.lang.String)"><!-- --></A><H3>
cudaLaunch</H3>
<PRE>
public static int <B>cudaLaunch</B>(java.lang.String&nbsp;symbol)</PRE>
<DL>
<DD>Launches a device function.
 <br />
 <br />
 SYNOPSIS<br />
 template &lt; class T &gt; cudaError_t cudaLaunch(T entry)
 <br />
 <br />
 DESCRIPTION<br />
 Launches the function entry on the device. entry can either be a function that executes on the device,
 or it can be a character string, naming a function that executes on the device. entry must be declared as
 a __global__ function. cudaLaunch() must be preceded by a call to cudaConfigureCall() since it
 pops the data that was pushed by cudaConfigureCall() from the execution stack.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDeviceFunction, cudaErrorInvalidConfiguration,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)"><CODE>cudaConfigureCall(jcuda.runtime.dim3, jcuda.runtime.dim3, long, jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaSetupArgument(jcuda.Pointer, long, long)"><CODE>cudaSetupArgument(jcuda.Pointer, long, long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLSetGLDevice(int)"><!-- --></A><H3>
cudaGLSetGLDevice</H3>
<PRE>
public static int <B>cudaGLSetGLDevice</B>(int&nbsp;device)</PRE>
<DL>
<DD>Sets the CUDA device for use with GL Interopability.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGLSetGLDevice(int device);
 <br />
 <br />
 DESCRIPTION<br />
 Records dev as the device on which the active host thread executes the device code. Records the thread as
 using GL Interopability.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)"><CODE>cudaGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)"><CODE>cudaGLMapBufferObject(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)"><CODE>cudaGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)"><CODE>cudaGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)"><!-- --></A><H3>
cudaGraphicsGLRegisterImage</H3>
<PRE>
public static int <B>cudaGraphicsGLRegisterImage</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                              int&nbsp;image,
                                              int&nbsp;target,
                                              int&nbsp;Flags)</PRE>
<DL>
<DD>Registers the texture or renderbuffer object specified by image for 
 access by CUDA. target must match the type of the object. A handle 
 to the registered object is returned as resource. The map flags 
 Flags specify the intended usage, as follows:<br />
 <br />
 <ul>
 <li> cudaGraphicsMapFlagsNone: Specifies no hints about how this 
      resource will be used. It is therefore assumed that this 
      resource will be read from and written to by CUDA. This is 
      the default value.
 </li>
 <li> cudaGraphicsMapFlagsReadOnly: Specifies that CUDA will not 
      write to this resource.
 </li>
 <li> cudaGraphicsMapFlagsWriteDiscard: Specifies that CUDA will 
      not read from this resource and will write over the entire 
      contents of the resource, so none of the data previously 
      stored in the resource will be preserved.
 </li>
 </ul>
 <br />
 Parameters:<br />
 resource    - Pointer to the returned object handle<br />
 image   - name of texture or renderbuffer object to be registered<br />
 target  - Identifies the type of object specified by image, and must be 
 one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, 
 GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, or GL_RENDERBUFFER.<br />
 flags   - Map flags<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorInvalidValue, 
 cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)"><CODE>cudaGLSetGLDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><!-- --></A><H3>
cudaGraphicsGLRegisterBuffer</H3>
<PRE>
public static int <B>cudaGraphicsGLRegisterBuffer</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                               int&nbsp;buffer,
                                               int&nbsp;Flags)</PRE>
<DL>
<DD>Registers the buffer object specified by buffer for access by CUDA. A handle 
 to the registered object is returned as resource. The map flags Flags specify 
 the intended usage, as follows:<br />
 <ul>
 <li>cudaGraphicsMapFlagsNone: Specifies no hints about how this resource will 
     be used. It is therefore assumed that this resource will be read from and 
     written to by CUDA. This is the default value.
 </li>
 <li>cudaGraphicsMapFlagsReadOnly: Specifies that CUDA will not write to this resource.</li>
 <li>cudaGraphicsMapFlagsWriteDiscard: Specifies that CUDA will not read from this 
     resource and will write over the entire contents of the resource, so none of 
     the data previously stored in the resource will be preserved.
 </li>
 </ul>
 <br />
 Parameters:<br />
 resource    - Pointer to the returned object handle<br />
 buffer  - name of buffer object to be registered<br />
 flags   - Map flags<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevice, cudaErrorInvalidValue, 
 cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLRegisterBufferObject(int)"><!-- --></A><H3>
cudaGLRegisterBufferObject</H3>
<PRE>
public static int <B>cudaGLRegisterBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>OpenGL interoperability.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGLRegisterBufferObject(GLuint bufferObj)
 <br />
 <br />
 DESCRIPTION<br />
 Registers the buffer object of ID bufferObj for access by CUDA. This function must be called before CUDA
 can map the buffer object. While it is registered, the buffer object cannot be used by any OpenGL commands
 except as a data source for OpenGL drawing commands.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorNotInitialized,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)"><CODE>cudaGLSetGLDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)"><CODE>cudaGLMapBufferObject(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)"><CODE>cudaGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)"><CODE>cudaGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLMapBufferObject(jcuda.Pointer, int)"><!-- --></A><H3>
cudaGLMapBufferObject</H3>
<PRE>
public static int <B>cudaGLMapBufferObject</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                        int&nbsp;bufObj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>OpenGL interoperability.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGLMapBufferObject(void** devPtr, GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Maps the buffer object of ID bufferObj into the address space of CUDA and returns in *devPtr the base
 pointer of the resulting mapping.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)"><CODE>cudaGLSetGLDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)"><CODE>cudaGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)"><CODE>cudaGLUnmapBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)"><CODE>cudaGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnmapBufferObject(int)"><!-- --></A><H3>
cudaGLUnmapBufferObject</H3>
<PRE>
public static int <B>cudaGLUnmapBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>OpenGL interoperability.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGLUnmapBufferObject(GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Unmaps the buffer object of ID bufferObj for access by CUDA.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer, cudaErrorUnmapBufferObjectFailed,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)"><CODE>cudaGLSetGLDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)"><CODE>cudaGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)"><CODE>cudaGLMapBufferObject(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnregisterBufferObject(int)"><CODE>cudaGLUnregisterBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnregisterBufferObject(int)"><!-- --></A><H3>
cudaGLUnregisterBufferObject</H3>
<PRE>
public static int <B>cudaGLUnregisterBufferObject</B>(int&nbsp;bufObj)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>OpenGL interoperability.
 <br />
 <br />
 SYNOPSIS<br />
 cudaError_t cudaGLUnregisterBufferObject(GLuint bufferObj);
 <br />
 <br />
 DESCRIPTION<br />
 Unregisters the buffer object of ID bufferObj for access by CUDA.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess,<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGLSetGLDevice(int)"><CODE>cudaGLSetGLDevice(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLRegisterBufferObject(int)"><CODE>cudaGLRegisterBufferObject(int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLMapBufferObject(jcuda.Pointer, int)"><CODE>cudaGLMapBufferObject(jcuda.Pointer, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGLUnmapBufferObject(int)"><CODE>cudaGLUnmapBufferObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLSetBufferObjectMapFlags(int, int)"><!-- --></A><H3>
cudaGLSetBufferObjectMapFlags</H3>
<PRE>
public static int <B>cudaGLSetBufferObjectMapFlags</B>(int&nbsp;bufObj,
                                                int&nbsp;flags)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Set flags for mapping the OpenGL buffer bufObj.<br />
 <br />
 Changes to flags will take effect the next time bufObj is mapped. 
 The flags argument may be any of the following:<br />
 <ul>
   <li>cudaGLMapFlagsNone: Specifies no hints about how this buffer 
       will be used. It is therefore assumed that this buffer will 
       be read from and written to by CUDA kernels. This is the 
       default value.
   </li>
   <li>cudaGLMapFlagsReadOnly: Specifies that CUDA kernels which 
       access this buffer will not write to the buffer.
   </li>
   <li>cudaGLMapFlagsWriteDiscard: Specifies that CUDA kernels which 
       access this buffer will not read from the buffer and will write 
       over the entire contents of the buffer, so none of the data 
       previously stored in the buffer will be preserved.
   </li>
 </ul>
 <br />
 If bufObj has not been registered for use with CUDA, then 
 cudaErrorInvalidResourceHandle is returned. If bufObj is presently 
 mapped for access by CUDA, then cudaErrorUnknown is returned.<br />
 <br />
 Parameters:<br />
 bufObj  - Registered buffer object to set flags for<br />
 flags   - Parameters for buffer mapping<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)"><CODE>cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLMapBufferObjectAsync(jcuda.Pointer, int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGLMapBufferObjectAsync</H3>
<PRE>
public static int <B>cudaGLMapBufferObjectAsync</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                             int&nbsp;bufObj,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Maps the buffer object of ID bufObj into the address space of CUDA and 
 returns in *devPtr the base pointer of the resulting mapping. The buffer 
 must have previously been registered by calling cudaGLRegisterBufferObject(). 
 While a buffer is mapped by CUDA, any OpenGL operation which references the
 buffer will result in undefined behavior. The OpenGL context used to create 
 the buffer, or another context from the same share group, must be bound to 
 the current thread when this is called.<br />
 <br />
 <br />
 Stream stream is synchronized with the current GL context.<br />
 <br />
 Parameters:<br />
 devPtr  - Returned device pointer to CUDA object<br />
 bufObj  - Buffer object ID to map<br />
 stream  - Stream to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorMapBufferObjectFailed
 <br />
 #see JCudacudaGraphicsMapResources</DL>
</DD>
</DL>
<HR>

<A NAME="cudaGLUnmapBufferObjectAsync(int, jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGLUnmapBufferObjectAsync</H3>
<PRE>
public static int <B>cudaGLUnmapBufferObjectAsync</B>(int&nbsp;bufObj,
                                               <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of CUDA 3.0</I>
<P>
<DD>Unmaps the buffer object of ID bufObj for access by CUDA. When a buffer is 
 unmapped, the base address returned by cudaGLMapBufferObject() is invalid 
 and subsequent references to the address result in undefined behavior. The 
 OpenGL context used to create the buffer, or another context from the same 
 share group, must be bound to the current thread when this is called.<br />
 <br />
 Stream stream is synchronized with the current GL context.<br />
 <br />
 Parameters:<br />
 bufObj  - Buffer object to unmap<br />
 stream  - Stream to synchronize<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidDevicePointer, cudaErrorUnmapBufferObjectFailed
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaDriverGetVersion(int[])"><!-- --></A><H3>
cudaDriverGetVersion</H3>
<PRE>
public static int <B>cudaDriverGetVersion</B>(int[]&nbsp;driverVersion)</PRE>
<DL>
<DD>Returns in driverVersion the version number of the installed CUDA driver. If no driver is installed, then 0 is
 returned as the driver version (via driverVersion). This function automatically returns cudaErrorInvalidValue if
 the driverVersion argument is NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverVersion</CODE> - - Returns the CUDA driver version.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaRuntimeGetVersion(int[])"><CODE>cudaRuntimeGetVersion(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaRuntimeGetVersion(int[])"><!-- --></A><H3>
cudaRuntimeGetVersion</H3>
<PRE>
public static int <B>cudaRuntimeGetVersion</B>(int[]&nbsp;runtimeVersion)</PRE>
<DL>
<DD>Returns in runtimeVersion the version number of the installed CUDA Runtime. This function automatically
 returns cudaErrorInvalidValue if the runtimeVersion argument is NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>runtimeVersion</CODE> - - Returns the CUDA Runtime version.
<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue<DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaDriverGetVersion(int[])"><CODE>cudaDriverGetVersion(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsUnregisterResource(jcuda.runtime.cudaGraphicsResource)"><!-- --></A><H3>
cudaGraphicsUnregisterResource</H3>
<PRE>
public static int <B>cudaGraphicsUnregisterResource</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Unregisters the graphics resource resource so it is not 
 accessible by CUDA unless registered again.<br />
 <br />
 If resource is invalid then cudaErrorInvalidResourceHandle is returned.
 <br />
 Parameters:<br />
 resource    - Resource to unregister<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsGLRegisterBuffer(jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)"><CODE>cudaGraphicsGLRegisterImage(jcuda.runtime.cudaGraphicsResource, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsResourceSetMapFlags(jcuda.runtime.cudaGraphicsResource, int)"><!-- --></A><H3>
cudaGraphicsResourceSetMapFlags</H3>
<PRE>
public static int <B>cudaGraphicsResourceSetMapFlags</B>(<A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                                  int&nbsp;flags)</PRE>
<DL>
<DD>Set flags for mapping the graphics resource resource.<br />
 <br />
 Changes to flags will take effect the next time resource is mapped. 
 The flags argument may be any of the following:
 <ul>
   <li> cudaGraphicsMapFlagsNone: Specifies no hints about how resource 
        will be used. It is therefore assumed that CUDA may read from 
        or write to resource.
   </li>
   <li>cudaGraphicsMapFlagsReadOnly: Specifies that CUDA will not write to resource.</li>
   <li>cudaGraphicsMapFlagsWriteDiscard: Specifies CUDA will not read from resource 
       and will write over the entire contents of resource, so none of the data 
       previously stored in resource will be preserved.
   </li>
 </ul>
 <br /> 
 If resource is presently mapped for access by CUDA then cudaErrorUnknown is returned. 
 If flags is not one of the above values then cudaErrorInvalidValue is returned.<br />
 <br />
 Parameters:<br />
 resource    - Registered resource to set flags for<br />
 flags   - Parameters for resource mapping<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle, cudaErrorUnknown,
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGraphicsMapResources</H3>
<PRE>
public static int <B>cudaGraphicsMapResources</B>(int&nbsp;count,
                                           <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                                           <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Maps the count graphics resources in resources for access by CUDA.<br />
 <br />
 The resources in resources may be accessed by CUDA until they are unmapped. 
 The graphics API from which resources were registered should not access any 
 resources while they are mapped by CUDA. If an application does so, the 
 results are undefined.<br />
 <br />
 This function provides the synchronization guarantee that any graphics calls 
 issued before cudaGraphicsMapResources() will complete before any subsequent 
 CUDA work issued in stream begins.<br />
 <br />
 If resources contains any duplicate entries then cudaErrorInvalidResourceHandle 
 is returned. If any of resources are presently mapped for access by CUDA then 
 cudaErrorUnknown is returned.<br />
 <br />
 Parameters:<br />
 count   - Number of resources to map<br />
 resources   - Resources to map for CUDA<br />
 stream  - Stream for synchronization<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsUnmapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><!-- --></A><H3>
cudaGraphicsUnmapResources</H3>
<PRE>
public static int <B>cudaGraphicsUnmapResources</B>(int&nbsp;count,
                                             <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>[]&nbsp;resources,
                                             <A HREF="../../jcuda/runtime/cudaStream_t.html" title="class in jcuda.runtime">cudaStream_t</A>&nbsp;stream)</PRE>
<DL>
<DD>Unmaps the count graphics resources in resources.<br />
 <br />
 Once unmapped, the resources in resources may not be 
 accessed by CUDA until they are mapped again.<br />
 <br />
 This function provides the synchronization guarantee that any 
 CUDA work issued in stream before cudaGraphicsUnmapResources() 
 will complete before any subsequently issued graphics work begins.<br />
 <br />
 If resources contains any duplicate entries then 
 cudaErrorInvalidResourceHandle is returned. If any of resources are 
 not presently mapped for access by Cuda then cudaErrorUnknown is 
 returned.<br />
 <br />
 Parameters:<br />
 count   - Number of resources to unmap<br />
 resources   - Resources to unmap<br />
 stream  - Stream for synchronization<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><!-- --></A><H3>
cudaGraphicsResourceGetMappedPointer</H3>
<PRE>
public static int <B>cudaGraphicsResourceGetMappedPointer</B>(<A HREF="../../jcuda/Pointer.html" title="class in jcuda">Pointer</A>&nbsp;devPtr,
                                                       long[]&nbsp;size,
                                                       <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource)</PRE>
<DL>
<DD>Returns in *devPtr a pointer through which the mapped graphics resource resource 
 may be accessed. Returns in *size the size of the memory in bytes which may be 
 accessed from that pointer. The value set in devPtr may change every time that 
 resource is mapped.<br />
 <br />
 If resource is not a buffer then it cannot be accessed via a pointer and 
 cudaErrorUnknown is returned. If resource is not mapped then cudaErrorUnknown 
 is returned. <br />
 <br />
 Parameters:<br />
 devPtr  - Returned pointer through which resource may be accessed<br />
 size    - Returned size of the buffer accessible starting at *devPtr<br />
 resource    - Mapped resource to access<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)"><CODE>cudaGraphicsMapResources(int, jcuda.runtime.cudaGraphicsResource[], jcuda.runtime.cudaStream_t)</CODE></A>, 
<A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><CODE>cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cudaGraphicsSubResourceGetMappedArray(jcuda.runtime.cudaArray, jcuda.runtime.cudaGraphicsResource, int, int)"><!-- --></A><H3>
cudaGraphicsSubResourceGetMappedArray</H3>
<PRE>
public static int <B>cudaGraphicsSubResourceGetMappedArray</B>(<A HREF="../../jcuda/runtime/cudaArray.html" title="class in jcuda.runtime">cudaArray</A>&nbsp;arrayPtr,
                                                        <A HREF="../../jcuda/runtime/cudaGraphicsResource.html" title="class in jcuda.runtime">cudaGraphicsResource</A>&nbsp;resource,
                                                        int&nbsp;arrayIndex,
                                                        int&nbsp;mipLevel)</PRE>
<DL>
<DD>Returns in *array an array through which the subresource of the mapped 
 graphics resource resource which corresponds to array index arrayIndex 
 and mipmap level mipLevel may be accessed. The value set in array may 
 change every time that resource is mapped.<br />
 <br />
 If resource is not a texture then it cannot be accessed via an array 
 and cudaErrorUnknown is returned. If arrayIndex is not a valid array 
 index for resource then cudaErrorInvalidValue is returned. If mipLevel 
 is not a valid mipmap level for resource then cudaErrorInvalidValue 
 is returned. If resource is not mapped then cudaErrorUnknown is returned.
 <br />
 <br />
 Parameters:<br />
 array   - Returned array through which a subresource of resource may be accessed<br />
 resource    - Mapped resource to access<br />
 arrayIndex  - Array index for array textures or cubemap face index as 
 defined by cudaGraphicsCubeFace for cubemap textures for the subresource to access<br />
 mipLevel    - Mipmap level for the subresource to access<br />
 <br />
<P>
<DD><DL>

<DT><B>Returns:</B><DD>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidResourceHandle, cudaErrorUnknown
 <br /><DT><B>See Also:</B><DD><A HREF="../../jcuda/runtime/JCuda.html#cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)"><CODE>cudaGraphicsResourceGetMappedPointer(jcuda.Pointer, long[], jcuda.runtime.cudaGraphicsResource)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JCuda.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jcuda/runtime/dim3.html" title="class in jcuda.runtime"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jcuda/runtime/textureReference.html" title="class in jcuda.runtime"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?jcuda/runtime/JCuda.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JCuda.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
